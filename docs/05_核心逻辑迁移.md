# 核心逻辑迁移

## 📋 本文档内容

- 游戏主循环改造
- WordTetrisGame.js → GameManager.ts 转换
- 单词管理系统迁移
- 输入系统重建
- 状态管理优化

---

## 1️⃣ 核心代码对比

### 1.1 游戏循环对比

**原 HTML5 Canvas 版本：**

```javascript
// proj/src/core/WordTetrisGame.js
class WordTetrisGame {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.lastFrameTime = 0;
        this.gameState = 'ready';
    }
    
    // 游戏主循环
    gameLoop(currentTime) {
        const deltaTime = currentTime - this.lastFrameTime;
        this.lastFrameTime = currentTime;
        
        if (this.gameState === 'playing') {
            this.update(deltaTime);
            this.render();
        }
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    update(deltaTime) {
        // 更新单词位置
        this.updateWords(deltaTime);
        // 更新炮弹
        this.updateBullets(deltaTime);
        // 更新粒子
        this.updateParticles(deltaTime);
    }
    
    render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBackground();
        this.drawWords();
        this.drawCannon();
        this.drawBullets();
        this.drawParticles();
    }
}
```

**Cocos Creator 版本：**

```typescript
// proj-cocos/assets/scripts/core/GameManager.ts
import { _decorator, Component, Node } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('GameManager')
export class GameManager extends Component {
    @property(Node)
    canvas: Node = null;
    
    private gameState: GameState = GameState.Ready;
    private isPaused: boolean = false;
    
    /**
     * 生命周期：组件加载完成
     */
    protected onLoad(): void {
        this.initializeGame();
    }
    
    /**
     * 生命周期：游戏开始（首帧之前）
     */
    protected start(): void {
        this.startGame();
    }
    
    /**
     * 生命周期：每帧更新
     * @param deltaTime 帧间隔时间（秒）
     */
    protected update(deltaTime: number): void {
        if (this.gameState !== GameState.Playing || this.isPaused) {
            return;
        }
        
        // 更新游戏逻辑
        this.updateWords(deltaTime);
        this.updateBullets(deltaTime);
        this.updateParticles(deltaTime);
    }
    
    /**
     * 初始化游戏
     */
    private initializeGame(): void {
        // 初始化管理器
        this.initManagers();
        // 加载资源
        this.loadResources();
        // 设置监听器
        this.setupListeners();
    }
    
    /**
     * 开始游戏
     */
    public startGame(): void {
        this.gameState = GameState.Playing;
        this.releaseNextWord();
    }
    
    /**
     * 暂停游戏
     */
    public pauseGame(): void {
        this.isPaused = true;
        this.gameState = GameState.Paused;
    }
    
    /**
     * 恢复游戏
     */
    public resumeGame(): void {
        this.isPaused = false;
        this.gameState = GameState.Playing;
    }
}
```

**关键差异：**

| 特性 | HTML5 Canvas | Cocos Creator |
|------|-------------|---------------|
| **游戏循环** | `requestAnimationFrame` | `update(deltaTime)` |
| **时间单位** | 毫秒（需要自己计算） | 秒（引擎自动计算） |
| **渲染** | 手动调用 `render()` | 引擎自动渲染节点树 |
| **状态管理** | 简单变量 | 枚举 + 状态机 |
| **生命周期** | 手动控制 | 引擎提供生命周期钩子 |

---

## 2️⃣ GameManager 完整实现

### 2.1 类型定义

首先创建类型定义文件：

```typescript
// assets/scripts/types/GameState.ts

/**
 * 游戏状态枚举
 */
export enum GameState {
    Ready = 'ready',
    Playing = 'playing',
    Paused = 'paused',
    LevelUp = 'levelup',
    GameOver = 'gameover'
}

/**
 * 游戏统计数据
 */
export interface GameStats {
    score: number;
    level: number;
    combo: number;
    time: number;
    totalWords: number;
    hitWords: number;
    missedWords: string[];
    hitWordsSet: Set<string>;
    droppedWordsSet: Set<string>;
}

/**
 * 游戏配置
 */
export interface GameConfig {
    canvasWidth: number;
    canvasHeight: number;
    baseFallSpeed: number;
    speedIncrement: number;
    scorePerLetter: number;
    shootBonus: number;
}
```

### 2.2 GameManager 主类

```typescript
// assets/scripts/core/GameManager.ts
import { _decorator, Component, Node, Vec3, Prefab, instantiate } from 'cc';
import { WordManager } from './WordManager';
import { ScoreManager } from './ScoreManager';
import { InputManager } from './InputManager';
import { BufferManager } from './BufferManager';
import { CannonSystem } from '../systems/CannonSystem';
import { ExplosionSystem } from '../systems/ExplosionSystem';
import { GameState, GameStats, GameConfig } from '../types/GameState';

const { ccclass, property } = _decorator;

@ccclass('GameManager')
export class GameManager extends Component {
    // ========== 属性检查器引用 ==========
    
    @property(Node)
    gameLayer: Node = null;
    
    @property(Node)
    uiLayer: Node = null;
    
    @property(WordManager)
    wordManager: WordManager = null;
    
    @property(ScoreManager)
    scoreManager: ScoreManager = null;
    
    @property(InputManager)
    inputManager: InputManager = null;
    
    @property(BufferManager)
    bufferManager: BufferManager = null;
    
    @property(CannonSystem)
    cannonSystem: CannonSystem = null;
    
    @property(ExplosionSystem)
    explosionSystem: ExplosionSystem = null;
    
    // ========== 游戏状态 ==========
    
    private gameState: GameState = GameState.Ready;
    private isPaused: boolean = false;
    private gameStats: GameStats = {
        score: 0,
        level: 1,
        combo: 0,
        time: 0,
        totalWords: 0,
        hitWords: 0,
        missedWords: [],
        hitWordsSet: new Set(),
        droppedWordsSet: new Set()
    };
    
    private gameConfig: GameConfig = {
        canvasWidth: 600,
        canvasHeight: 500,
        baseFallSpeed: 0.2,
        speedIncrement: 0.05,
        scorePerLetter: 1,
        shootBonus: 2
    };
    
    // ========== 生命周期 ==========
    
    protected onLoad(): void {
        console.log('GameManager: onLoad');
        this.initializeGame();
    }
    
    protected start(): void {
        console.log('GameManager: start');
        // 不自动开始，等待用户点击"开始游戏"按钮
    }
    
    protected update(deltaTime: number): void {
        if (this.gameState !== GameState.Playing || this.isPaused) {
            return;
        }
        
        // 更新游戏时间
        this.gameStats.time += deltaTime;
        
        // 更新各个系统
        this.wordManager.update(deltaTime);
        this.cannonSystem.update(deltaTime);
        this.explosionSystem.update(deltaTime);
        
        // 更新炮管瞄准
        const currentWord = this.wordManager.getCurrentWord();
        if (currentWord) {
            const worldPos = currentWord.node.getWorldPosition();
            this.cannonSystem.aimAt(worldPos);
        }
    }
    
    protected onDestroy(): void {
        this.cleanup();
    }
    
    // ========== 初始化 ==========
    
    private async initializeGame(): Promise<void> {
        try {
            // 1. 加载配置
            await this.loadGameConfig();
            
            // 2. 初始化各个管理器
            await this.wordManager.initialize();
            this.scoreManager.initialize();
            this.inputManager.initialize(this);
            this.bufferManager.initialize();
            this.cannonSystem.initialize();
            this.explosionSystem.initialize();
            
            // 3. 设置事件监听
            this.setupEventListeners();
            
            console.log('✅ 游戏初始化完成');
            
        } catch (error) {
            console.error('❌ 游戏初始化失败:', error);
        }
    }
    
    private async loadGameConfig(): Promise<void> {
        // 从配置文件加载游戏配置
        // TODO: 实现配置加载
    }
    
    private setupEventListeners(): void {
        // 监听输入事件
        this.inputManager.on('input-complete', this.onInputComplete, this);
        this.inputManager.on('give-up', this.onGiveUp, this);
        
        // 监听缓冲区事件
        this.bufferManager.on('countdown-complete', this.onCountdownComplete, this);
        
        // 监听单词事件
        this.wordManager.on('word-stacked', this.onWordStacked, this);
        this.wordManager.on('word-hit-bottom', this.onWordHitBottom, this);
    }
    
    // ========== 游戏控制 ==========
    
    public startGame(): void {
        if (this.gameState === GameState.Ready || this.gameState === GameState.GameOver) {
            this.resetGameStats();
            this.gameState = GameState.Playing;
            this.isPaused = false;
            
            // 开始释放单词
            this.releaseNextWord();
            
            console.log('🎮 游戏开始');
        }
    }
    
    public pauseGame(): void {
        if (this.gameState === GameState.Playing) {
            this.isPaused = true;
            this.gameState = GameState.Paused;
            
            // 暂停音频
            // TODO: 停止 TTS 播放
            
            console.log('⏸️ 游戏暂停');
        }
    }
    
    public resumeGame(): void {
        if (this.gameState === GameState.Paused) {
            this.isPaused = false;
            this.gameState = GameState.Playing;
            
            console.log('▶️ 游戏继续');
        }
    }
    
    public resetGame(): void {
        // 清理所有单词
        this.wordManager.clearAllWords();
        
        // 重置统计数据
        this.resetGameStats();
        
        // 重置状态
        this.gameState = GameState.Ready;
        this.isPaused = false;
        
        console.log('🔄 游戏重置');
    }
    
    private resetGameStats(): void {
        this.gameStats = {
            score: 0,
            level: 1,
            combo: 0,
            time: 0,
            totalWords: 0,
            hitWords: 0,
            missedWords: [],
            hitWordsSet: new Set(),
            droppedWordsSet: new Set()
        };
        
        this.scoreManager.resetStats();
    }
    
    // ========== 单词流程 ==========
    
    private releaseNextWord(): void {
        if (this.gameState !== GameState.Playing) {
            return;
        }
        
        // 1. 从单词管理器获取下一个单词
        const wordData = this.wordManager.getNextWord();
        if (!wordData) {
            console.warn('⚠️ 没有更多单词了');
            return;
        }
        
        // 2. 放入缓冲区
        this.bufferManager.loadWord(wordData);
        
        // 3. 开始倒计时
        this.bufferManager.startCountdown();
    }
    
    private onCountdownComplete(): void {
        // 缓冲区倒计时完成，释放单词到游戏区域
        const wordData = this.bufferManager.releaseWord();
        
        if (wordData) {
            this.wordManager.spawnWord(wordData);
            this.gameStats.totalWords++;
        }
    }
    
    // ========== 输入处理 ==========
    
    private onInputComplete(input: string): void {
        const currentWord = this.wordManager.getCurrentWord();
        if (!currentWord) {
            return;
        }
        
        // 验证输入
        const isCorrect = currentWord.validateInput(input);
        
        if (isCorrect) {
            // 射击成功
            this.handleCorrectInput(currentWord);
        } else {
            // 输入错误
            this.handleWrongInput(currentWord);
        }
    }
    
    private handleCorrectInput(word: WordEntity): void {
        // 1. 播放射击动画
        const wordPos = word.node.getWorldPosition();
        this.cannonSystem.fire(wordPos);
        
        // 2. 爆炸效果
        this.explosionSystem.createExplosion(wordPos, word.getMeaning());
        
        // 3. 移除单词
        this.wordManager.removeWord(word);
        
        // 4. 更新分数
        const points = this.calculatePoints(word);
        this.scoreManager.addScore(points);
        
        // 5. 更新统计
        this.gameStats.combo++;
        this.gameStats.hitWords++;
        this.gameStats.hitWordsSet.add(word.getWord());
        
        // 6. 检查等级提升
        this.checkLevelUp();
        
        // 7. 释放下一个单词
        this.releaseNextWord();
    }
    
    private handleWrongInput(word: WordEntity): void {
        // 显示错误标记
        word.showRedCross();
        
        // 重置连击
        this.gameStats.combo = 0;
        
        // 清空输入
        this.inputManager.clearInput();
    }
    
    private onGiveUp(): void {
        const currentWord = this.wordManager.getCurrentWord();
        if (!currentWord) {
            return;
        }
        
        // 放入堆叠区
        this.wordManager.stackWord(currentWord);
        
        // 添加到生词本
        this.gameStats.missedWords.push(currentWord.getWord());
        
        // 重置连击
        this.gameStats.combo = 0;
        
        // 释放下一个单词
        this.releaseNextWord();
    }
    
    // ========== 碰撞和堆叠 ==========
    
    private onWordStacked(word: WordEntity): void {
        // 单词被堆叠
        this.gameStats.missedWords.push(word.getWord());
        
        // 检查是否游戏结束
        this.checkGameOver();
        
        // 释放下一个单词
        this.releaseNextWord();
    }
    
    private onWordHitBottom(): void {
        // 检查堆叠区是否满
        this.checkGameOver();
    }
    
    // ========== 分数和等级 ==========
    
    private calculatePoints(word: WordEntity): number {
        let points = 0;
        
        // 基础分数
        points += word.getMissingLettersCount() * this.gameConfig.scorePerLetter;
        
        // 射击奖励
        points += this.gameConfig.shootBonus;
        
        // 连击奖励
        if (this.gameStats.combo >= 3) {
            points += 1 * this.gameStats.combo;
        }
        
        // 速度奖励
        // TODO: 根据输入速度计算
        
        return points;
    }
    
    private checkLevelUp(): void {
        const currentScore = this.scoreManager.getScore();
        const nextLevelThreshold = this.scoreManager.getNextLevelThreshold();
        
        if (currentScore >= nextLevelThreshold) {
            this.levelUp();
        }
    }
    
    private levelUp(): void {
        this.gameState = GameState.LevelUp;
        this.gameStats.level++;
        
        // 清空堆叠区
        this.wordManager.clearStackedWords();
        
        // 显示等级提升弹窗
        // TODO: 触发UI事件
        
        console.log(`🎉 等级提升到 ${this.gameStats.level}！`);
        
        // 恢复游戏
        setTimeout(() => {
            this.gameState = GameState.Playing;
            this.releaseNextWord();
        }, 2000);
    }
    
    // ========== 游戏结束 ==========
    
    private checkGameOver(): void {
        const isStackFull = this.wordManager.isStackFull();
        
        if (isStackFull) {
            this.gameOver();
        }
    }
    
    private gameOver(): void {
        this.gameState = GameState.GameOver;
        
        // 停止所有音频
        // TODO: 停止 TTS
        
        // 显示游戏结束弹窗
        // TODO: 触发UI事件
        
        console.log('🎮 游戏结束！');
        console.log(`最终分数: ${this.gameStats.score}`);
        console.log(`达到等级: ${this.gameStats.level}`);
        console.log(`生词数量: ${this.gameStats.missedWords.length}`);
    }
    
    // ========== 清理 ==========
    
    private cleanup(): void {
        // 移除事件监听
        this.inputManager.off('input-complete', this.onInputComplete, this);
        this.inputManager.off('give-up', this.onGiveUp, this);
        this.bufferManager.off('countdown-complete', this.onCountdownComplete, this);
        this.wordManager.off('word-stacked', this.onWordStacked, this);
        this.wordManager.off('word-hit-bottom', this.onWordHitBottom, this);
        
        // 清理资源
        this.wordManager.cleanup();
        this.explosionSystem.cleanup();
    }
    
    // ========== 公共接口 ==========
    
    public getGameState(): GameState {
        return this.gameState;
    }
    
    public getGameStats(): GameStats {
        return { ...this.gameStats };
    }
    
    public isPausedState(): boolean {
        return this.isPaused;
    }
}
```

---

## 3️⃣ 单词管理器迁移

### 3.1 WordManager 实现

```typescript
// assets/scripts/core/WordManager.ts
import { _decorator, Component, Node, Prefab, instantiate, Vec3, NodePool } from 'cc';
import { WordEntity } from '../entities/WordEntity';
import { WordData } from '../types/Word';
import { ResourceManager } from '../utils/ResourceManager';

const { ccclass, property } = _decorator;

@ccclass('WordManager')
export class WordManager extends Component {
    @property(Prefab)
    wordPrefab: Prefab = null;
    
    @property(Node)
    wordsContainer: Node = null;
    
    @property(Node)
    stackContainer: Node = null;
    
    // 单词数据
    private allWords: WordData[] = [];
    private currentWordIndex: number = 0;
    private currentWord: WordEntity = null;
    private stackedWords: WordEntity[] = [];
    
    // 对象池
    private wordPool: NodePool = new NodePool();
    
    // 配置
    private readonly STACK_MAX_HEIGHT = 400;
    private readonly WORD_HEIGHT = 40;
    
    /**
     * 初始化
     */
    public async initialize(): Promise<void> {
        console.log('WordManager: 初始化');
        
        // 加载单词库
        await this.loadVocabulary();
        
        // 初始化对象池
        this.initPool();
        
        console.log(`✅ 单词库加载完成，共 ${this.allWords.length} 个单词`);
    }
    
    /**
     * 加载单词库
     */
    private async loadVocabulary(): Promise<void> {
        const resourceManager = ResourceManager.getInstance();
        
        try {
            // 1. 加载配置
            const config = await resourceManager.loadVocabularyConfig();
            
            // 2. 加载用户选择的词库
            const selectedLibraries = this.getSelectedLibraries();
            
            // 3. 加载所有词库文件
            const promises = selectedLibraries.map(lib => 
                resourceManager.loadVocabulary(lib.path)
            );
            
            const results = await Promise.all(promises);
            
            // 4. 合并单词数据
            this.allWords = [];
            for (const result of results) {
                if (result && result.words) {
                    this.allWords.push(...result.words);
                }
            }
            
            // 5. 打乱顺序
            this.shuffleWords();
            
        } catch (error) {
            console.error('❌ 加载单词库失败:', error);
        }
    }
    
    /**
     * 获取用户选择的词库列表
     */
    private getSelectedLibraries(): any[] {
        // 从本地存储读取用户选择
        // TODO: 实现
        return [
            { path: 'daily-phonics/day01' },
            { path: 'daily-phonics/day02' }
        ];
    }
    
    /**
     * 打乱单词顺序
     */
    private shuffleWords(): void {
        for (let i = this.allWords.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.allWords[i], this.allWords[j]] = [this.allWords[j], this.allWords[i]];
        }
    }
    
    /**
     * 初始化对象池
     */
    private initPool(): void {
        // 预创建10个单词对象
        for (let i = 0; i < 10; i++) {
            const node = instantiate(this.wordPrefab);
            this.wordPool.put(node);
        }
    }
    
    /**
     * 获取下一个单词数据
     */
    public getNextWord(): WordData | null {
        if (this.currentWordIndex >= this.allWords.length) {
            return null;
        }
        
        const wordData = this.allWords[this.currentWordIndex];
        this.currentWordIndex++;
        
        return wordData;
    }
    
    /**
     * 生成单词节点
     */
    public spawnWord(wordData: WordData): WordEntity {
        // 从对象池获取或创建节点
        let node = this.wordPool.size() > 0 
            ? this.wordPool.get() 
            : instantiate(this.wordPrefab);
        
        // 添加到容器
        this.wordsContainer.addChild(node);
        
        // 获取 WordEntity 组件
        const wordEntity = node.getComponent(WordEntity);
        
        // 初始化单词
        wordEntity.init(wordData);
        
        // 设置初始位置（随机 x 坐标）
        const randomX = this.getRandomX(wordEntity.getWidth());
        node.setPosition(randomX, 250, 0);
        
        // 保存当前单词
        this.currentWord = wordEntity;
        
        return wordEntity;
    }
    
    /**
     * 获取随机 x 坐标
     */
    private getRandomX(wordWidth: number): number {
        const margin = 20;
        const minX = wordWidth / 2 + margin;
        const maxX = 600 - wordWidth / 2 - margin;
        
        return Math.random() * (maxX - minX) + minX;
    }
    
    /**
     * 移除单词（射击成功）
     */
    public removeWord(word: WordEntity): void {
        if (word === this.currentWord) {
            this.currentWord = null;
        }
        
        // 播放消失动画
        word.playDestroyAnimation(() => {
            // 回收到对象池
            word.node.removeFromParent();
            this.wordPool.put(word.node);
        });
    }
    
    /**
     * 堆叠单词（放弃或失败）
     */
    public stackWord(word: WordEntity): void {
        if (word === this.currentWord) {
            this.currentWord = null;
        }
        
        // 从主容器移除
        word.node.removeFromParent();
        
        // 添加到堆叠容器
        this.stackContainer.addChild(word.node);
        
        // 计算堆叠位置
        const stackY = this.stackedWords.length * this.WORD_HEIGHT;
        word.node.setPosition(0, stackY, 0);
        
        // 标记为堆叠状态
        word.setStacked(true);
        
        // 添加到堆叠列表
        this.stackedWords.push(word);
        
        // 发送事件
        this.node.emit('word-stacked', word);
    }
    
    /**
     * 清空堆叠区
     */
    public clearStackedWords(): void {
        for (const word of this.stackedWords) {
            word.node.removeFromParent();
            this.wordPool.put(word.node);
        }
        
        this.stackedWords = [];
    }
    
    /**
     * 清空所有单词
     */
    public clearAllWords(): void {
        // 清空当前单词
        if (this.currentWord) {
            this.currentWord.node.removeFromParent();
            this.wordPool.put(this.currentWord.node);
            this.currentWord = null;
        }
        
        // 清空堆叠区
        this.clearStackedWords();
    }
    
    /**
     * 每帧更新
     */
    public update(deltaTime: number): void {
        if (this.currentWord) {
            // 更新单词下降
            this.currentWord.fall(deltaTime);
            
            // 检查是否到达底部
            if (this.currentWord.node.position.y <= -200) {
                this.stackWord(this.currentWord);
                this.node.emit('word-hit-bottom');
            }
        }
    }
    
    /**
     * 检查堆叠区是否已满
     */
    public isStackFull(): boolean {
        const stackHeight = this.stackedWords.length * this.WORD_HEIGHT;
        return stackHeight >= this.STACK_MAX_HEIGHT;
    }
    
    /**
     * 获取当前单词
     */
    public getCurrentWord(): WordEntity | null {
        return this.currentWord;
    }
    
    /**
     * 清理
     */
    public cleanup(): void {
        this.clearAllWords();
        this.wordPool.clear();
    }
}
```

---

## 4️⃣ 输入管理器实现

### 4.1 InputManager

```typescript
// assets/scripts/core/InputManager.ts
import { _decorator, Component, Node, systemEvent, SystemEvent, KeyCode, EventKeyboard } from 'cc';

const { ccclass, property } = _decorator;

@ccclass('InputManager')
export class InputManager extends Component {
    private gameManager: any = null;
    private inputText: string = '';
    private isEnabled: boolean = false;
    
    /**
     * 初始化
     */
    public initialize(gameManager: any): void {
        this.gameManager = gameManager;
        this.setupKeyboardListeners();
    }
    
    /**
     * 设置键盘监听
     */
    private setupKeyboardListeners(): void {
        systemEvent.on(SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);
    }
    
    /**
     * 键盘按下事件
     */
    private onKeyDown(event: EventKeyboard): void {
        if (!this.isEnabled) {
            return;
        }
        
        const keyCode = event.keyCode;
        
        // 字母键（A-Z）
        if (keyCode >= KeyCode.KEY_A && keyCode <= KeyCode.KEY_Z) {
            const letter = String.fromCharCode(keyCode).toUpperCase();
            this.addLetter(letter);
        }
        // 回车键：提交
        else if (keyCode === KeyCode.ENTER) {
            this.submit();
        }
        // 退格键：删除
        else if (keyCode === KeyCode.BACKSPACE) {
            this.deleteLetter();
        }
        // 空格键：放弃
        else if (keyCode === KeyCode.SPACE) {
            this.giveUp();
        }
    }
    
    /**
     * 添加字母
     */
    private addLetter(letter: string): void {
        this.inputText += letter;
        this.node.emit('input-change', this.inputText);
    }
    
    /**
     * 删除字母
     */
    private deleteLetter(): void {
        if (this.inputText.length > 0) {
            this.inputText = this.inputText.slice(0, -1);
            this.node.emit('input-change', this.inputText);
        }
    }
    
    /**
     * 提交输入
     */
    private submit(): void {
        if (this.inputText.length === 0) {
            return;
        }
        
        this.node.emit('input-complete', this.inputText);
        // 不立即清空，等待验证结果
    }
    
    /**
     * 放弃当前单词
     */
    private giveUp(): void {
        this.clearInput();
        this.node.emit('give-up');
    }
    
    /**
     * 清空输入
     */
    public clearInput(): void {
        this.inputText = '';
        this.node.emit('input-change', this.inputText);
    }
    
    /**
     * 获取当前输入
     */
    public getInput(): string {
        return this.inputText;
    }
    
    /**
     * 启用/禁用输入
     */
    public setEnabled(enabled: boolean): void {
        this.isEnabled = enabled;
    }
    
    /**
     * 清理
     */
    protected onDestroy(): void {
        systemEvent.off(SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);
    }
}
```

---

## 5️⃣ 迁移步骤总结

### 步骤 1：创建脚本框架
1. 创建所有 TS 脚本文件
2. 定义类型和接口
3. 设置属性检查器引用

### 步骤 2：实现核心逻辑
1. GameManager 游戏流程
2. WordManager 单词管理
3. InputManager 输入处理
4. ScoreManager 分数管理
5. BufferManager 缓冲区管理

### 步骤 3：测试验证
1. 单词加载
2. 单词显示
3. 输入响应
4. 射击逻辑
5. 分数计算

---

**核心逻辑迁移完成！** ✅

下一步：阅读 [06_渲染系统改造.md](./06_渲染系统改造.md)

