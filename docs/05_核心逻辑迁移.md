# æ ¸å¿ƒé€»è¾‘è¿ç§»

## ğŸ“‹ æœ¬æ–‡æ¡£å†…å®¹

- æ¸¸æˆä¸»å¾ªç¯æ”¹é€ 
- WordTetrisGame.js â†’ GameManager.ts è½¬æ¢
- å•è¯ç®¡ç†ç³»ç»Ÿè¿ç§»
- è¾“å…¥ç³»ç»Ÿé‡å»º
- çŠ¶æ€ç®¡ç†ä¼˜åŒ–

---

## 1ï¸âƒ£ æ ¸å¿ƒä»£ç å¯¹æ¯”

### 1.1 æ¸¸æˆå¾ªç¯å¯¹æ¯”

**åŸ HTML5 Canvas ç‰ˆæœ¬ï¼š**

```javascript
// proj/src/core/WordTetrisGame.js
class WordTetrisGame {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.lastFrameTime = 0;
        this.gameState = 'ready';
    }
    
    // æ¸¸æˆä¸»å¾ªç¯
    gameLoop(currentTime) {
        const deltaTime = currentTime - this.lastFrameTime;
        this.lastFrameTime = currentTime;
        
        if (this.gameState === 'playing') {
            this.update(deltaTime);
            this.render();
        }
        
        requestAnimationFrame((time) => this.gameLoop(time));
    }
    
    update(deltaTime) {
        // æ›´æ–°å•è¯ä½ç½®
        this.updateWords(deltaTime);
        // æ›´æ–°ç‚®å¼¹
        this.updateBullets(deltaTime);
        // æ›´æ–°ç²’å­
        this.updateParticles(deltaTime);
    }
    
    render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBackground();
        this.drawWords();
        this.drawCannon();
        this.drawBullets();
        this.drawParticles();
    }
}
```

**Cocos Creator ç‰ˆæœ¬ï¼š**

```typescript
// proj-cocos/assets/scripts/core/GameManager.ts
import { _decorator, Component, Node } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('GameManager')
export class GameManager extends Component {
    @property(Node)
    canvas: Node = null;
    
    private gameState: GameState = GameState.Ready;
    private isPaused: boolean = false;
    
    /**
     * ç”Ÿå‘½å‘¨æœŸï¼šç»„ä»¶åŠ è½½å®Œæˆ
     */
    protected onLoad(): void {
        this.initializeGame();
    }
    
    /**
     * ç”Ÿå‘½å‘¨æœŸï¼šæ¸¸æˆå¼€å§‹ï¼ˆé¦–å¸§ä¹‹å‰ï¼‰
     */
    protected start(): void {
        this.startGame();
    }
    
    /**
     * ç”Ÿå‘½å‘¨æœŸï¼šæ¯å¸§æ›´æ–°
     * @param deltaTime å¸§é—´éš”æ—¶é—´ï¼ˆç§’ï¼‰
     */
    protected update(deltaTime: number): void {
        if (this.gameState !== GameState.Playing || this.isPaused) {
            return;
        }
        
        // æ›´æ–°æ¸¸æˆé€»è¾‘
        this.updateWords(deltaTime);
        this.updateBullets(deltaTime);
        this.updateParticles(deltaTime);
    }
    
    /**
     * åˆå§‹åŒ–æ¸¸æˆ
     */
    private initializeGame(): void {
        // åˆå§‹åŒ–ç®¡ç†å™¨
        this.initManagers();
        // åŠ è½½èµ„æº
        this.loadResources();
        // è®¾ç½®ç›‘å¬å™¨
        this.setupListeners();
    }
    
    /**
     * å¼€å§‹æ¸¸æˆ
     */
    public startGame(): void {
        this.gameState = GameState.Playing;
        this.releaseNextWord();
    }
    
    /**
     * æš‚åœæ¸¸æˆ
     */
    public pauseGame(): void {
        this.isPaused = true;
        this.gameState = GameState.Paused;
    }
    
    /**
     * æ¢å¤æ¸¸æˆ
     */
    public resumeGame(): void {
        this.isPaused = false;
        this.gameState = GameState.Playing;
    }
}
```

**å…³é”®å·®å¼‚ï¼š**

| ç‰¹æ€§ | HTML5 Canvas | Cocos Creator |
|------|-------------|---------------|
| **æ¸¸æˆå¾ªç¯** | `requestAnimationFrame` | `update(deltaTime)` |
| **æ—¶é—´å•ä½** | æ¯«ç§’ï¼ˆéœ€è¦è‡ªå·±è®¡ç®—ï¼‰ | ç§’ï¼ˆå¼•æ“è‡ªåŠ¨è®¡ç®—ï¼‰ |
| **æ¸²æŸ“** | æ‰‹åŠ¨è°ƒç”¨ `render()` | å¼•æ“è‡ªåŠ¨æ¸²æŸ“èŠ‚ç‚¹æ ‘ |
| **çŠ¶æ€ç®¡ç†** | ç®€å•å˜é‡ | æšä¸¾ + çŠ¶æ€æœº |
| **ç”Ÿå‘½å‘¨æœŸ** | æ‰‹åŠ¨æ§åˆ¶ | å¼•æ“æä¾›ç”Ÿå‘½å‘¨æœŸé’©å­ |

---

## 2ï¸âƒ£ GameManager å®Œæ•´å®ç°

### 2.1 ç±»å‹å®šä¹‰

é¦–å…ˆåˆ›å»ºç±»å‹å®šä¹‰æ–‡ä»¶ï¼š

```typescript
// assets/scripts/types/GameState.ts

/**
 * æ¸¸æˆçŠ¶æ€æšä¸¾
 */
export enum GameState {
    Ready = 'ready',
    Playing = 'playing',
    Paused = 'paused',
    LevelUp = 'levelup',
    GameOver = 'gameover'
}

/**
 * æ¸¸æˆç»Ÿè®¡æ•°æ®
 */
export interface GameStats {
    score: number;
    level: number;
    combo: number;
    time: number;
    totalWords: number;
    hitWords: number;
    missedWords: string[];
    hitWordsSet: Set<string>;
    droppedWordsSet: Set<string>;
}

/**
 * æ¸¸æˆé…ç½®
 */
export interface GameConfig {
    canvasWidth: number;
    canvasHeight: number;
    baseFallSpeed: number;
    speedIncrement: number;
    scorePerLetter: number;
    shootBonus: number;
}
```

### 2.2 GameManager ä¸»ç±»

```typescript
// assets/scripts/core/GameManager.ts
import { _decorator, Component, Node, Vec3, Prefab, instantiate } from 'cc';
import { WordManager } from './WordManager';
import { ScoreManager } from './ScoreManager';
import { InputManager } from './InputManager';
import { BufferManager } from './BufferManager';
import { CannonSystem } from '../systems/CannonSystem';
import { ExplosionSystem } from '../systems/ExplosionSystem';
import { GameState, GameStats, GameConfig } from '../types/GameState';

const { ccclass, property } = _decorator;

@ccclass('GameManager')
export class GameManager extends Component {
    // ========== å±æ€§æ£€æŸ¥å™¨å¼•ç”¨ ==========
    
    @property(Node)
    gameLayer: Node = null;
    
    @property(Node)
    uiLayer: Node = null;
    
    @property(WordManager)
    wordManager: WordManager = null;
    
    @property(ScoreManager)
    scoreManager: ScoreManager = null;
    
    @property(InputManager)
    inputManager: InputManager = null;
    
    @property(BufferManager)
    bufferManager: BufferManager = null;
    
    @property(CannonSystem)
    cannonSystem: CannonSystem = null;
    
    @property(ExplosionSystem)
    explosionSystem: ExplosionSystem = null;
    
    // ========== æ¸¸æˆçŠ¶æ€ ==========
    
    private gameState: GameState = GameState.Ready;
    private isPaused: boolean = false;
    private gameStats: GameStats = {
        score: 0,
        level: 1,
        combo: 0,
        time: 0,
        totalWords: 0,
        hitWords: 0,
        missedWords: [],
        hitWordsSet: new Set(),
        droppedWordsSet: new Set()
    };
    
    private gameConfig: GameConfig = {
        canvasWidth: 600,
        canvasHeight: 500,
        baseFallSpeed: 0.2,
        speedIncrement: 0.05,
        scorePerLetter: 1,
        shootBonus: 2
    };
    
    // ========== ç”Ÿå‘½å‘¨æœŸ ==========
    
    protected onLoad(): void {
        console.log('GameManager: onLoad');
        this.initializeGame();
    }
    
    protected start(): void {
        console.log('GameManager: start');
        // ä¸è‡ªåŠ¨å¼€å§‹ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"æŒ‰é’®
    }
    
    protected update(deltaTime: number): void {
        if (this.gameState !== GameState.Playing || this.isPaused) {
            return;
        }
        
        // æ›´æ–°æ¸¸æˆæ—¶é—´
        this.gameStats.time += deltaTime;
        
        // æ›´æ–°å„ä¸ªç³»ç»Ÿ
        this.wordManager.update(deltaTime);
        this.cannonSystem.update(deltaTime);
        this.explosionSystem.update(deltaTime);
        
        // æ›´æ–°ç‚®ç®¡ç„å‡†
        const currentWord = this.wordManager.getCurrentWord();
        if (currentWord) {
            const worldPos = currentWord.node.getWorldPosition();
            this.cannonSystem.aimAt(worldPos);
        }
    }
    
    protected onDestroy(): void {
        this.cleanup();
    }
    
    // ========== åˆå§‹åŒ– ==========
    
    private async initializeGame(): Promise<void> {
        try {
            // 1. åŠ è½½é…ç½®
            await this.loadGameConfig();
            
            // 2. åˆå§‹åŒ–å„ä¸ªç®¡ç†å™¨
            await this.wordManager.initialize();
            this.scoreManager.initialize();
            this.inputManager.initialize(this);
            this.bufferManager.initialize();
            this.cannonSystem.initialize();
            this.explosionSystem.initialize();
            
            // 3. è®¾ç½®äº‹ä»¶ç›‘å¬
            this.setupEventListeners();
            
            console.log('âœ… æ¸¸æˆåˆå§‹åŒ–å®Œæˆ');
            
        } catch (error) {
            console.error('âŒ æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
        }
    }
    
    private async loadGameConfig(): Promise<void> {
        // ä»é…ç½®æ–‡ä»¶åŠ è½½æ¸¸æˆé…ç½®
        // TODO: å®ç°é…ç½®åŠ è½½
    }
    
    private setupEventListeners(): void {
        // ç›‘å¬è¾“å…¥äº‹ä»¶
        this.inputManager.on('input-complete', this.onInputComplete, this);
        this.inputManager.on('give-up', this.onGiveUp, this);
        
        // ç›‘å¬ç¼“å†²åŒºäº‹ä»¶
        this.bufferManager.on('countdown-complete', this.onCountdownComplete, this);
        
        // ç›‘å¬å•è¯äº‹ä»¶
        this.wordManager.on('word-stacked', this.onWordStacked, this);
        this.wordManager.on('word-hit-bottom', this.onWordHitBottom, this);
    }
    
    // ========== æ¸¸æˆæ§åˆ¶ ==========
    
    public startGame(): void {
        if (this.gameState === GameState.Ready || this.gameState === GameState.GameOver) {
            this.resetGameStats();
            this.gameState = GameState.Playing;
            this.isPaused = false;
            
            // å¼€å§‹é‡Šæ”¾å•è¯
            this.releaseNextWord();
            
            console.log('ğŸ® æ¸¸æˆå¼€å§‹');
        }
    }
    
    public pauseGame(): void {
        if (this.gameState === GameState.Playing) {
            this.isPaused = true;
            this.gameState = GameState.Paused;
            
            // æš‚åœéŸ³é¢‘
            // TODO: åœæ­¢ TTS æ’­æ”¾
            
            console.log('â¸ï¸ æ¸¸æˆæš‚åœ');
        }
    }
    
    public resumeGame(): void {
        if (this.gameState === GameState.Paused) {
            this.isPaused = false;
            this.gameState = GameState.Playing;
            
            console.log('â–¶ï¸ æ¸¸æˆç»§ç»­');
        }
    }
    
    public resetGame(): void {
        // æ¸…ç†æ‰€æœ‰å•è¯
        this.wordManager.clearAllWords();
        
        // é‡ç½®ç»Ÿè®¡æ•°æ®
        this.resetGameStats();
        
        // é‡ç½®çŠ¶æ€
        this.gameState = GameState.Ready;
        this.isPaused = false;
        
        console.log('ğŸ”„ æ¸¸æˆé‡ç½®');
    }
    
    private resetGameStats(): void {
        this.gameStats = {
            score: 0,
            level: 1,
            combo: 0,
            time: 0,
            totalWords: 0,
            hitWords: 0,
            missedWords: [],
            hitWordsSet: new Set(),
            droppedWordsSet: new Set()
        };
        
        this.scoreManager.resetStats();
    }
    
    // ========== å•è¯æµç¨‹ ==========
    
    private releaseNextWord(): void {
        if (this.gameState !== GameState.Playing) {
            return;
        }
        
        // 1. ä»å•è¯ç®¡ç†å™¨è·å–ä¸‹ä¸€ä¸ªå•è¯
        const wordData = this.wordManager.getNextWord();
        if (!wordData) {
            console.warn('âš ï¸ æ²¡æœ‰æ›´å¤šå•è¯äº†');
            return;
        }
        
        // 2. æ”¾å…¥ç¼“å†²åŒº
        this.bufferManager.loadWord(wordData);
        
        // 3. å¼€å§‹å€’è®¡æ—¶
        this.bufferManager.startCountdown();
    }
    
    private onCountdownComplete(): void {
        // ç¼“å†²åŒºå€’è®¡æ—¶å®Œæˆï¼Œé‡Šæ”¾å•è¯åˆ°æ¸¸æˆåŒºåŸŸ
        const wordData = this.bufferManager.releaseWord();
        
        if (wordData) {
            this.wordManager.spawnWord(wordData);
            this.gameStats.totalWords++;
        }
    }
    
    // ========== è¾“å…¥å¤„ç† ==========
    
    private onInputComplete(input: string): void {
        const currentWord = this.wordManager.getCurrentWord();
        if (!currentWord) {
            return;
        }
        
        // éªŒè¯è¾“å…¥
        const isCorrect = currentWord.validateInput(input);
        
        if (isCorrect) {
            // å°„å‡»æˆåŠŸ
            this.handleCorrectInput(currentWord);
        } else {
            // è¾“å…¥é”™è¯¯
            this.handleWrongInput(currentWord);
        }
    }
    
    private handleCorrectInput(word: WordEntity): void {
        // 1. æ’­æ”¾å°„å‡»åŠ¨ç”»
        const wordPos = word.node.getWorldPosition();
        this.cannonSystem.fire(wordPos);
        
        // 2. çˆ†ç‚¸æ•ˆæœ
        this.explosionSystem.createExplosion(wordPos, word.getMeaning());
        
        // 3. ç§»é™¤å•è¯
        this.wordManager.removeWord(word);
        
        // 4. æ›´æ–°åˆ†æ•°
        const points = this.calculatePoints(word);
        this.scoreManager.addScore(points);
        
        // 5. æ›´æ–°ç»Ÿè®¡
        this.gameStats.combo++;
        this.gameStats.hitWords++;
        this.gameStats.hitWordsSet.add(word.getWord());
        
        // 6. æ£€æŸ¥ç­‰çº§æå‡
        this.checkLevelUp();
        
        // 7. é‡Šæ”¾ä¸‹ä¸€ä¸ªå•è¯
        this.releaseNextWord();
    }
    
    private handleWrongInput(word: WordEntity): void {
        // æ˜¾ç¤ºé”™è¯¯æ ‡è®°
        word.showRedCross();
        
        // é‡ç½®è¿å‡»
        this.gameStats.combo = 0;
        
        // æ¸…ç©ºè¾“å…¥
        this.inputManager.clearInput();
    }
    
    private onGiveUp(): void {
        const currentWord = this.wordManager.getCurrentWord();
        if (!currentWord) {
            return;
        }
        
        // æ”¾å…¥å †å åŒº
        this.wordManager.stackWord(currentWord);
        
        // æ·»åŠ åˆ°ç”Ÿè¯æœ¬
        this.gameStats.missedWords.push(currentWord.getWord());
        
        // é‡ç½®è¿å‡»
        this.gameStats.combo = 0;
        
        // é‡Šæ”¾ä¸‹ä¸€ä¸ªå•è¯
        this.releaseNextWord();
    }
    
    // ========== ç¢°æ’å’Œå †å  ==========
    
    private onWordStacked(word: WordEntity): void {
        // å•è¯è¢«å †å 
        this.gameStats.missedWords.push(word.getWord());
        
        // æ£€æŸ¥æ˜¯å¦æ¸¸æˆç»“æŸ
        this.checkGameOver();
        
        // é‡Šæ”¾ä¸‹ä¸€ä¸ªå•è¯
        this.releaseNextWord();
    }
    
    private onWordHitBottom(): void {
        // æ£€æŸ¥å †å åŒºæ˜¯å¦æ»¡
        this.checkGameOver();
    }
    
    // ========== åˆ†æ•°å’Œç­‰çº§ ==========
    
    private calculatePoints(word: WordEntity): number {
        let points = 0;
        
        // åŸºç¡€åˆ†æ•°
        points += word.getMissingLettersCount() * this.gameConfig.scorePerLetter;
        
        // å°„å‡»å¥–åŠ±
        points += this.gameConfig.shootBonus;
        
        // è¿å‡»å¥–åŠ±
        if (this.gameStats.combo >= 3) {
            points += 1 * this.gameStats.combo;
        }
        
        // é€Ÿåº¦å¥–åŠ±
        // TODO: æ ¹æ®è¾“å…¥é€Ÿåº¦è®¡ç®—
        
        return points;
    }
    
    private checkLevelUp(): void {
        const currentScore = this.scoreManager.getScore();
        const nextLevelThreshold = this.scoreManager.getNextLevelThreshold();
        
        if (currentScore >= nextLevelThreshold) {
            this.levelUp();
        }
    }
    
    private levelUp(): void {
        this.gameState = GameState.LevelUp;
        this.gameStats.level++;
        
        // æ¸…ç©ºå †å åŒº
        this.wordManager.clearStackedWords();
        
        // æ˜¾ç¤ºç­‰çº§æå‡å¼¹çª—
        // TODO: è§¦å‘UIäº‹ä»¶
        
        console.log(`ğŸ‰ ç­‰çº§æå‡åˆ° ${this.gameStats.level}ï¼`);
        
        // æ¢å¤æ¸¸æˆ
        setTimeout(() => {
            this.gameState = GameState.Playing;
            this.releaseNextWord();
        }, 2000);
    }
    
    // ========== æ¸¸æˆç»“æŸ ==========
    
    private checkGameOver(): void {
        const isStackFull = this.wordManager.isStackFull();
        
        if (isStackFull) {
            this.gameOver();
        }
    }
    
    private gameOver(): void {
        this.gameState = GameState.GameOver;
        
        // åœæ­¢æ‰€æœ‰éŸ³é¢‘
        // TODO: åœæ­¢ TTS
        
        // æ˜¾ç¤ºæ¸¸æˆç»“æŸå¼¹çª—
        // TODO: è§¦å‘UIäº‹ä»¶
        
        console.log('ğŸ® æ¸¸æˆç»“æŸï¼');
        console.log(`æœ€ç»ˆåˆ†æ•°: ${this.gameStats.score}`);
        console.log(`è¾¾åˆ°ç­‰çº§: ${this.gameStats.level}`);
        console.log(`ç”Ÿè¯æ•°é‡: ${this.gameStats.missedWords.length}`);
    }
    
    // ========== æ¸…ç† ==========
    
    private cleanup(): void {
        // ç§»é™¤äº‹ä»¶ç›‘å¬
        this.inputManager.off('input-complete', this.onInputComplete, this);
        this.inputManager.off('give-up', this.onGiveUp, this);
        this.bufferManager.off('countdown-complete', this.onCountdownComplete, this);
        this.wordManager.off('word-stacked', this.onWordStacked, this);
        this.wordManager.off('word-hit-bottom', this.onWordHitBottom, this);
        
        // æ¸…ç†èµ„æº
        this.wordManager.cleanup();
        this.explosionSystem.cleanup();
    }
    
    // ========== å…¬å…±æ¥å£ ==========
    
    public getGameState(): GameState {
        return this.gameState;
    }
    
    public getGameStats(): GameStats {
        return { ...this.gameStats };
    }
    
    public isPausedState(): boolean {
        return this.isPaused;
    }
}
```

---

## 3ï¸âƒ£ å•è¯ç®¡ç†å™¨è¿ç§»

### 3.1 WordManager å®ç°

```typescript
// assets/scripts/core/WordManager.ts
import { _decorator, Component, Node, Prefab, instantiate, Vec3, NodePool } from 'cc';
import { WordEntity } from '../entities/WordEntity';
import { WordData } from '../types/Word';
import { ResourceManager } from '../utils/ResourceManager';

const { ccclass, property } = _decorator;

@ccclass('WordManager')
export class WordManager extends Component {
    @property(Prefab)
    wordPrefab: Prefab = null;
    
    @property(Node)
    wordsContainer: Node = null;
    
    @property(Node)
    stackContainer: Node = null;
    
    // å•è¯æ•°æ®
    private allWords: WordData[] = [];
    private currentWordIndex: number = 0;
    private currentWord: WordEntity = null;
    private stackedWords: WordEntity[] = [];
    
    // å¯¹è±¡æ± 
    private wordPool: NodePool = new NodePool();
    
    // é…ç½®
    private readonly STACK_MAX_HEIGHT = 400;
    private readonly WORD_HEIGHT = 40;
    
    /**
     * åˆå§‹åŒ–
     */
    public async initialize(): Promise<void> {
        console.log('WordManager: åˆå§‹åŒ–');
        
        // åŠ è½½å•è¯åº“
        await this.loadVocabulary();
        
        // åˆå§‹åŒ–å¯¹è±¡æ± 
        this.initPool();
        
        console.log(`âœ… å•è¯åº“åŠ è½½å®Œæˆï¼Œå…± ${this.allWords.length} ä¸ªå•è¯`);
    }
    
    /**
     * åŠ è½½å•è¯åº“
     */
    private async loadVocabulary(): Promise<void> {
        const resourceManager = ResourceManager.getInstance();
        
        try {
            // 1. åŠ è½½é…ç½®
            const config = await resourceManager.loadVocabularyConfig();
            
            // 2. åŠ è½½ç”¨æˆ·é€‰æ‹©çš„è¯åº“
            const selectedLibraries = this.getSelectedLibraries();
            
            // 3. åŠ è½½æ‰€æœ‰è¯åº“æ–‡ä»¶
            const promises = selectedLibraries.map(lib => 
                resourceManager.loadVocabulary(lib.path)
            );
            
            const results = await Promise.all(promises);
            
            // 4. åˆå¹¶å•è¯æ•°æ®
            this.allWords = [];
            for (const result of results) {
                if (result && result.words) {
                    this.allWords.push(...result.words);
                }
            }
            
            // 5. æ‰“ä¹±é¡ºåº
            this.shuffleWords();
            
        } catch (error) {
            console.error('âŒ åŠ è½½å•è¯åº“å¤±è´¥:', error);
        }
    }
    
    /**
     * è·å–ç”¨æˆ·é€‰æ‹©çš„è¯åº“åˆ—è¡¨
     */
    private getSelectedLibraries(): any[] {
        // ä»æœ¬åœ°å­˜å‚¨è¯»å–ç”¨æˆ·é€‰æ‹©
        // TODO: å®ç°
        return [
            { path: 'daily-phonics/day01' },
            { path: 'daily-phonics/day02' }
        ];
    }
    
    /**
     * æ‰“ä¹±å•è¯é¡ºåº
     */
    private shuffleWords(): void {
        for (let i = this.allWords.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.allWords[i], this.allWords[j]] = [this.allWords[j], this.allWords[i]];
        }
    }
    
    /**
     * åˆå§‹åŒ–å¯¹è±¡æ± 
     */
    private initPool(): void {
        // é¢„åˆ›å»º10ä¸ªå•è¯å¯¹è±¡
        for (let i = 0; i < 10; i++) {
            const node = instantiate(this.wordPrefab);
            this.wordPool.put(node);
        }
    }
    
    /**
     * è·å–ä¸‹ä¸€ä¸ªå•è¯æ•°æ®
     */
    public getNextWord(): WordData | null {
        if (this.currentWordIndex >= this.allWords.length) {
            return null;
        }
        
        const wordData = this.allWords[this.currentWordIndex];
        this.currentWordIndex++;
        
        return wordData;
    }
    
    /**
     * ç”Ÿæˆå•è¯èŠ‚ç‚¹
     */
    public spawnWord(wordData: WordData): WordEntity {
        // ä»å¯¹è±¡æ± è·å–æˆ–åˆ›å»ºèŠ‚ç‚¹
        let node = this.wordPool.size() > 0 
            ? this.wordPool.get() 
            : instantiate(this.wordPrefab);
        
        // æ·»åŠ åˆ°å®¹å™¨
        this.wordsContainer.addChild(node);
        
        // è·å– WordEntity ç»„ä»¶
        const wordEntity = node.getComponent(WordEntity);
        
        // åˆå§‹åŒ–å•è¯
        wordEntity.init(wordData);
        
        // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆéšæœº x åæ ‡ï¼‰
        const randomX = this.getRandomX(wordEntity.getWidth());
        node.setPosition(randomX, 250, 0);
        
        // ä¿å­˜å½“å‰å•è¯
        this.currentWord = wordEntity;
        
        return wordEntity;
    }
    
    /**
     * è·å–éšæœº x åæ ‡
     */
    private getRandomX(wordWidth: number): number {
        const margin = 20;
        const minX = wordWidth / 2 + margin;
        const maxX = 600 - wordWidth / 2 - margin;
        
        return Math.random() * (maxX - minX) + minX;
    }
    
    /**
     * ç§»é™¤å•è¯ï¼ˆå°„å‡»æˆåŠŸï¼‰
     */
    public removeWord(word: WordEntity): void {
        if (word === this.currentWord) {
            this.currentWord = null;
        }
        
        // æ’­æ”¾æ¶ˆå¤±åŠ¨ç”»
        word.playDestroyAnimation(() => {
            // å›æ”¶åˆ°å¯¹è±¡æ± 
            word.node.removeFromParent();
            this.wordPool.put(word.node);
        });
    }
    
    /**
     * å †å å•è¯ï¼ˆæ”¾å¼ƒæˆ–å¤±è´¥ï¼‰
     */
    public stackWord(word: WordEntity): void {
        if (word === this.currentWord) {
            this.currentWord = null;
        }
        
        // ä»ä¸»å®¹å™¨ç§»é™¤
        word.node.removeFromParent();
        
        // æ·»åŠ åˆ°å †å å®¹å™¨
        this.stackContainer.addChild(word.node);
        
        // è®¡ç®—å †å ä½ç½®
        const stackY = this.stackedWords.length * this.WORD_HEIGHT;
        word.node.setPosition(0, stackY, 0);
        
        // æ ‡è®°ä¸ºå †å çŠ¶æ€
        word.setStacked(true);
        
        // æ·»åŠ åˆ°å †å åˆ—è¡¨
        this.stackedWords.push(word);
        
        // å‘é€äº‹ä»¶
        this.node.emit('word-stacked', word);
    }
    
    /**
     * æ¸…ç©ºå †å åŒº
     */
    public clearStackedWords(): void {
        for (const word of this.stackedWords) {
            word.node.removeFromParent();
            this.wordPool.put(word.node);
        }
        
        this.stackedWords = [];
    }
    
    /**
     * æ¸…ç©ºæ‰€æœ‰å•è¯
     */
    public clearAllWords(): void {
        // æ¸…ç©ºå½“å‰å•è¯
        if (this.currentWord) {
            this.currentWord.node.removeFromParent();
            this.wordPool.put(this.currentWord.node);
            this.currentWord = null;
        }
        
        // æ¸…ç©ºå †å åŒº
        this.clearStackedWords();
    }
    
    /**
     * æ¯å¸§æ›´æ–°
     */
    public update(deltaTime: number): void {
        if (this.currentWord) {
            // æ›´æ–°å•è¯ä¸‹é™
            this.currentWord.fall(deltaTime);
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾åº•éƒ¨
            if (this.currentWord.node.position.y <= -200) {
                this.stackWord(this.currentWord);
                this.node.emit('word-hit-bottom');
            }
        }
    }
    
    /**
     * æ£€æŸ¥å †å åŒºæ˜¯å¦å·²æ»¡
     */
    public isStackFull(): boolean {
        const stackHeight = this.stackedWords.length * this.WORD_HEIGHT;
        return stackHeight >= this.STACK_MAX_HEIGHT;
    }
    
    /**
     * è·å–å½“å‰å•è¯
     */
    public getCurrentWord(): WordEntity | null {
        return this.currentWord;
    }
    
    /**
     * æ¸…ç†
     */
    public cleanup(): void {
        this.clearAllWords();
        this.wordPool.clear();
    }
}
```

---

## 4ï¸âƒ£ è¾“å…¥ç®¡ç†å™¨å®ç°

### 4.1 InputManager

```typescript
// assets/scripts/core/InputManager.ts
import { _decorator, Component, Node, systemEvent, SystemEvent, KeyCode, EventKeyboard } from 'cc';

const { ccclass, property } = _decorator;

@ccclass('InputManager')
export class InputManager extends Component {
    private gameManager: any = null;
    private inputText: string = '';
    private isEnabled: boolean = false;
    
    /**
     * åˆå§‹åŒ–
     */
    public initialize(gameManager: any): void {
        this.gameManager = gameManager;
        this.setupKeyboardListeners();
    }
    
    /**
     * è®¾ç½®é”®ç›˜ç›‘å¬
     */
    private setupKeyboardListeners(): void {
        systemEvent.on(SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);
    }
    
    /**
     * é”®ç›˜æŒ‰ä¸‹äº‹ä»¶
     */
    private onKeyDown(event: EventKeyboard): void {
        if (!this.isEnabled) {
            return;
        }
        
        const keyCode = event.keyCode;
        
        // å­—æ¯é”®ï¼ˆA-Zï¼‰
        if (keyCode >= KeyCode.KEY_A && keyCode <= KeyCode.KEY_Z) {
            const letter = String.fromCharCode(keyCode).toUpperCase();
            this.addLetter(letter);
        }
        // å›è½¦é”®ï¼šæäº¤
        else if (keyCode === KeyCode.ENTER) {
            this.submit();
        }
        // é€€æ ¼é”®ï¼šåˆ é™¤
        else if (keyCode === KeyCode.BACKSPACE) {
            this.deleteLetter();
        }
        // ç©ºæ ¼é”®ï¼šæ”¾å¼ƒ
        else if (keyCode === KeyCode.SPACE) {
            this.giveUp();
        }
    }
    
    /**
     * æ·»åŠ å­—æ¯
     */
    private addLetter(letter: string): void {
        this.inputText += letter;
        this.node.emit('input-change', this.inputText);
    }
    
    /**
     * åˆ é™¤å­—æ¯
     */
    private deleteLetter(): void {
        if (this.inputText.length > 0) {
            this.inputText = this.inputText.slice(0, -1);
            this.node.emit('input-change', this.inputText);
        }
    }
    
    /**
     * æäº¤è¾“å…¥
     */
    private submit(): void {
        if (this.inputText.length === 0) {
            return;
        }
        
        this.node.emit('input-complete', this.inputText);
        // ä¸ç«‹å³æ¸…ç©ºï¼Œç­‰å¾…éªŒè¯ç»“æœ
    }
    
    /**
     * æ”¾å¼ƒå½“å‰å•è¯
     */
    private giveUp(): void {
        this.clearInput();
        this.node.emit('give-up');
    }
    
    /**
     * æ¸…ç©ºè¾“å…¥
     */
    public clearInput(): void {
        this.inputText = '';
        this.node.emit('input-change', this.inputText);
    }
    
    /**
     * è·å–å½“å‰è¾“å…¥
     */
    public getInput(): string {
        return this.inputText;
    }
    
    /**
     * å¯ç”¨/ç¦ç”¨è¾“å…¥
     */
    public setEnabled(enabled: boolean): void {
        this.isEnabled = enabled;
    }
    
    /**
     * æ¸…ç†
     */
    protected onDestroy(): void {
        systemEvent.off(SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this);
    }
}
```

---

## 5ï¸âƒ£ è¿ç§»æ­¥éª¤æ€»ç»“

### æ­¥éª¤ 1ï¼šåˆ›å»ºè„šæœ¬æ¡†æ¶
1. åˆ›å»ºæ‰€æœ‰ TS è„šæœ¬æ–‡ä»¶
2. å®šä¹‰ç±»å‹å’Œæ¥å£
3. è®¾ç½®å±æ€§æ£€æŸ¥å™¨å¼•ç”¨

### æ­¥éª¤ 2ï¼šå®ç°æ ¸å¿ƒé€»è¾‘
1. GameManager æ¸¸æˆæµç¨‹
2. WordManager å•è¯ç®¡ç†
3. InputManager è¾“å…¥å¤„ç†
4. ScoreManager åˆ†æ•°ç®¡ç†
5. BufferManager ç¼“å†²åŒºç®¡ç†

### æ­¥éª¤ 3ï¼šæµ‹è¯•éªŒè¯
1. å•è¯åŠ è½½
2. å•è¯æ˜¾ç¤º
3. è¾“å…¥å“åº”
4. å°„å‡»é€»è¾‘
5. åˆ†æ•°è®¡ç®—

---

**æ ¸å¿ƒé€»è¾‘è¿ç§»å®Œæˆï¼** âœ…

ä¸‹ä¸€æ­¥ï¼šé˜…è¯» [06_æ¸²æŸ“ç³»ç»Ÿæ”¹é€ .md](./06_æ¸²æŸ“ç³»ç»Ÿæ”¹é€ .md)

