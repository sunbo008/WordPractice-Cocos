# UI ç³»ç»Ÿé‡å»º

## ğŸ“‹ æœ¬æ–‡æ¡£å†…å®¹

- HTML DOM åˆ° Cocos UI ç»„ä»¶è½¬æ¢
- ç•Œé¢å¸ƒå±€å®ç°
- äº¤äº’é€»è¾‘é‡å»º
- å“åº”å¼é€‚é…

---

## 1ï¸âƒ£ UI ç³»ç»Ÿå¯¹æ¯”

### 1.1 HTML DOM vs Cocos UI

| UI å…ƒç´  | HTML DOM | Cocos Creator |
|---------|----------|---------------|
| **æŒ‰é’®** | `<button>` | `cc.Button` ç»„ä»¶ |
| **è¾“å…¥æ¡†** | `<input>` | `cc.EditBox` ç»„ä»¶ |
| **æ–‡æœ¬** | `<div>`, `<span>` | `cc.Label` ç»„ä»¶ |
| **å›¾ç‰‡** | `<img>` | `cc.Sprite` ç»„ä»¶ |
| **å®¹å™¨** | `<div>` | `cc.Node` + Layout |
| **æ»šåŠ¨** | `overflow: scroll` | `cc.ScrollView` ç»„ä»¶ |
| **å¸ƒå±€** | CSS Flexbox/Grid | `cc.Layout` ç»„ä»¶ |
| **å¯¹é½** | CSS position | `cc.Widget` ç»„ä»¶ |
| **äº‹ä»¶** | `addEventListener` | `node.on(EVENT_TYPE)` |

---

## 2ï¸âƒ£ ä¸»ç•Œé¢å¸ƒå±€å®ç°

### 2.1 Canvas æ ¹èŠ‚ç‚¹è®¾ç½®

```typescript
// åœºæ™¯ä¸­çš„ Canvas èŠ‚ç‚¹é…ç½®
Canvas å±æ€§æ£€æŸ¥å™¨ï¼š
- Design Resolution: 1280 x 720
- Fit Height: true
- Fit Width: true
```

### 2.2 ä¸‰æ å¸ƒå±€ç»“æ„

æ ¹æ®è®¾è®¡æ–‡æ¡£ï¼Œå®ç°ä¸‰æ å¸ƒå±€ï¼š**å›¾ç‰‡å±•ç¤ºåŒº + æ¸¸æˆç”»å¸ƒ + ä¾§è¾¹æ **

```
Canvas (æ ¹èŠ‚ç‚¹)
â”œâ”€â”€ Camera (ç›¸æœº)
â”‚
â”œâ”€â”€ GameLayer (æ¸¸æˆå±‚)
â”‚   â””â”€â”€ ... (æ¸¸æˆå†…å®¹)
â”‚
â””â”€â”€ UILayer (UIå±‚)
    â”œâ”€â”€ TopBar (é¡¶éƒ¨ä¿¡æ¯æ )
    â”œâ”€â”€ ExamStats (è€ƒè¯•ç»Ÿè®¡æ )
    â”œâ”€â”€ LeftPanel (å·¦ä¾§é¢æ¿)
    â”‚   â”œâ”€â”€ ImageShowcase (å›¾ç‰‡å±•ç¤ºåŒº)
    â”‚   â””â”€â”€ ControlPanel (æ§åˆ¶é¢æ¿)
    â””â”€â”€ Sidebar (å³ä¾§è¾¹æ )
        â”œâ”€â”€ BufferIndicator (ç¼“å†²åŒºæŒ‡ç¤º)
        â”œâ”€â”€ VocabularyBook (ç”Ÿè¯æœ¬)
        â””â”€â”€ Instructions (æ¸¸æˆè¯´æ˜)
```

---

## 3ï¸âƒ£ UI ç»„ä»¶å®ç°

### 3.1 é¡¶éƒ¨ä¿¡æ¯æ ï¼ˆTopBarï¼‰

```typescript
// assets/scripts/ui/TopBar.ts
import { _decorator, Component, Node, Label } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('TopBar')
export class TopBar extends Component {
    // ä¿¡æ¯æ ‡ç­¾
    @property(Label)
    scoreLabel: Label = null;
    
    @property(Label)
    levelLabel: Label = null;
    
    @property(Label)
    targetLabel: Label = null;
    
    @property(Label)
    vocabCountLabel: Label = null;
    
    @property(Label)
    timeLabel: Label = null;
    
    @property(Label)
    comboLabel: Label = null;
    
    /**
     * æ›´æ–°åˆ†æ•°æ˜¾ç¤º
     */
    public updateScore(score: number): void {
        this.scoreLabel.string = score.toString();
    }
    
    /**
     * æ›´æ–°ç­‰çº§æ˜¾ç¤º
     */
    public updateLevel(level: number): void {
        this.levelLabel.string = level.toString();
    }
    
    /**
     * æ›´æ–°ç›®æ ‡åˆ†æ•°
     */
    public updateTarget(target: number): void {
        this.targetLabel.string = target.toString();
    }
    
    /**
     * æ›´æ–°å•è¯æ€»æ•°
     */
    public updateVocabCount(count: number): void {
        this.vocabCountLabel.string = count.toString();
    }
    
    /**
     * æ›´æ–°æ—¶é—´æ˜¾ç¤º
     */
    public updateTime(seconds: number): void {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        this.timeLabel.string = `${this.pad(minutes)}:${this.pad(secs)}`;
    }
    
    /**
     * æ›´æ–°è¿å‡»æ•°
     */
    public updateCombo(combo: number): void {
        this.comboLabel.string = combo.toString();
        
        // è¿å‡»æ•°å¤§äº3æ—¶é«˜äº®æ˜¾ç¤º
        if (combo >= 3) {
            this.comboLabel.color = new Color(255, 215, 0); // é‡‘é»„è‰²
            this.playScaleAnimation(this.comboLabel.node);
        } else {
            this.comboLabel.color = Color.WHITE;
        }
    }
    
    /**
     * æ•°å­—è¡¥é›¶
     */
    private pad(num: number): string {
        return num < 10 ? '0' + num : num.toString();
    }
    
    /**
     * æ’­æ”¾ç¼©æ”¾åŠ¨ç”»
     */
    private playScaleAnimation(node: Node): void {
        tween(node)
            .to(0.1, { scale: new Vec3(1.2, 1.2, 1) })
            .to(0.1, { scale: new Vec3(1.0, 1.0, 1) })
            .start();
    }
}
```

#### TopBar åœºæ™¯æ­å»º

```
TopBar (Node + Layout)
â”œâ”€â”€ ScoreItem (Node + Layout)
â”‚   â”œâ”€â”€ Label_Score (Label) "åˆ†æ•°:"
â”‚   â””â”€â”€ Value_Score (Label) "0"
â”œâ”€â”€ LevelItem (Node + Layout)
â”‚   â”œâ”€â”€ Label_Level (Label) "ç­‰çº§:"
â”‚   â””â”€â”€ Value_Level (Label) "1"
â”œâ”€â”€ TargetItem (Node + Layout)
â”‚   â”œâ”€â”€ Label_Target (Label) "ç›®æ ‡:"
â”‚   â””â”€â”€ Value_Target (Label) "100"
â”œâ”€â”€ VocabItem (Node + Layout)
â”‚   â”œâ”€â”€ Label_Vocab (Label) "å•è¯æ€»æ•°:"
â”‚   â””â”€â”€ Value_Vocab (Label) "0"
â”œâ”€â”€ TimeItem (Node + Layout)
â”‚   â”œâ”€â”€ Label_Time (Label) "æ—¶é—´:"
â”‚   â””â”€â”€ Value_Time (Label) "00:00"
â””â”€â”€ ComboItem (Node + Layout)
    â”œâ”€â”€ Label_Combo (Label) "è¿å‡»:"
    â””â”€â”€ Value_Combo (Label) "0"
```

**Layout ç»„ä»¶é…ç½®ï¼š**
- Type: HORIZONTALï¼ˆæ°´å¹³å¸ƒå±€ï¼‰
- Resize Mode: CONTAINERï¼ˆå®¹å™¨è‡ªé€‚åº”ï¼‰
- Spacing: 20ï¼ˆé—´è·ï¼‰
- Padding: 10ï¼ˆå†…è¾¹è·ï¼‰

---

### 3.2 å›¾ç‰‡å±•ç¤ºåŒºï¼ˆImageShowcaseï¼‰

```typescript
// assets/scripts/ui/ImageShowcase.ts
import { _decorator, Component, Node, Sprite, Label, SpriteFrame, 
         resources, tween, Vec3 } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('ImageShowcase')
export class ImageShowcase extends Component {
    @property(Sprite)
    wordImage: Sprite = null; // å•è¯å›¾ç‰‡
    
    @property(Label)
    wordLabel: Label = null; // è‹±æ–‡å•è¯
    
    @property(Label)
    phoneticLabel: Label = null; // éŸ³æ ‡
    
    @property(Label)
    meaningLabel: Label = null; // ä¸­æ–‡é‡Šä¹‰
    
    @property(Node)
    loadingIndicator: Node = null; // åŠ è½½æŒ‡ç¤ºå™¨
    
    private currentWord: string = '';
    
    /**
     * æ›´æ–°å•è¯æ˜¾ç¤º
     */
    public async updateWord(word: string, phonetic: string, meaning: string): Promise<void> {
        if (this.currentWord === word) {
            return; // ç›¸åŒå•è¯ï¼Œä¸é‡å¤åŠ è½½
        }
        
        this.currentWord = word;
        
        // æ›´æ–°æ–‡å­—ä¿¡æ¯
        this.wordLabel.string = word.toLowerCase();
        this.phoneticLabel.string = phonetic;
        this.meaningLabel.string = meaning;
        
        // åŠ è½½å›¾ç‰‡
        await this.loadImage(word);
    }
    
    /**
     * åŠ è½½å•è¯å›¾ç‰‡
     */
    private async loadImage(word: string): Promise<void> {
        // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
        this.showLoading(true);
        
        try {
            // 1. å°è¯•ä»æœ¬åœ°èµ„æºåŠ è½½
            const localFrame = await this.loadLocalImage(word);
            if (localFrame) {
                this.wordImage.spriteFrame = localFrame;
                this.playFadeInAnimation();
                this.showLoading(false);
                return;
            }
            
            // 2. å°è¯•ä»ç½‘ç»œåŠ è½½
            const remoteFrame = await this.loadRemoteImage(word);
            if (remoteFrame) {
                this.wordImage.spriteFrame = remoteFrame;
                this.playFadeInAnimation();
                this.showLoading(false);
                return;
            }
            
            // 3. æ˜¾ç¤ºå ä½ç¬¦
            this.showPlaceholder(word);
            this.showLoading(false);
            
        } catch (error) {
            console.error('åŠ è½½å›¾ç‰‡å¤±è´¥:', error);
            this.showPlaceholder(word);
            this.showLoading(false);
        }
    }
    
    /**
     * åŠ è½½æœ¬åœ°å›¾ç‰‡
     */
    private loadLocalImage(word: string): Promise<SpriteFrame> {
        return new Promise((resolve, reject) => {
            const path = `images/words/${word}`;
            resources.load(path, SpriteFrame, (err, frame) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(frame);
                }
            });
        });
    }
    
    /**
     * åŠ è½½ç½‘ç»œå›¾ç‰‡
     */
    private loadRemoteImage(word: string): Promise<SpriteFrame> {
        return new Promise((resolve, reject) => {
            const url = `https://source.unsplash.com/200x200/?${word}`;
            
            assetManager.loadRemote(url, (err, texture: Texture2D) => {
                if (err) {
                    reject(err);
                } else {
                    const frame = new SpriteFrame();
                    frame.texture = texture;
                    resolve(frame);
                }
            });
        });
    }
    
    /**
     * æ˜¾ç¤ºå ä½ç¬¦
     */
    private showPlaceholder(word: string): void {
        // æ˜¾ç¤ºé¦–å­—æ¯å¤§å†™
        const placeholder = word[0].toUpperCase();
        
        // åˆ›å»ºå ä½ç¬¦çº¹ç†ï¼ˆä½¿ç”¨ Graphicsï¼‰
        // TODO: å®ç°å ä½ç¬¦ç”Ÿæˆ
    }
    
    /**
     * æ˜¾ç¤º/éšè—åŠ è½½æŒ‡ç¤ºå™¨
     */
    private showLoading(show: boolean): void {
        if (this.loadingIndicator) {
            this.loadingIndicator.active = show;
        }
    }
    
    /**
     * æ·¡å…¥åŠ¨ç”»
     */
    private playFadeInAnimation(): void {
        const uiOpacity = this.wordImage.node.getComponent(UIOpacity) || 
                         this.wordImage.node.addComponent(UIOpacity);
        
        uiOpacity.opacity = 0;
        
        tween(uiOpacity)
            .to(0.5, { opacity: 255 })
            .start();
    }
    
    /**
     * æˆåŠŸé—ªçƒåŠ¨ç”»
     */
    public playSuccessAnimation(): void {
        const originalColor = this.wordImage.color.clone();
        const greenColor = new Color(76, 175, 80);
        
        tween(this.wordImage)
            .to(0.2, { color: greenColor })
            .to(0.2, { color: originalColor })
            .union()
            .repeat(3)
            .start();
    }
    
    /**
     * é”™è¯¯æŠ–åŠ¨åŠ¨ç”»
     */
    public playErrorAnimation(): void {
        const originalPos = this.node.position.clone();
        
        tween(this.node)
            .to(0.05, { position: new Vec3(originalPos.x + 5, originalPos.y, 0) })
            .to(0.05, { position: new Vec3(originalPos.x - 5, originalPos.y, 0) })
            .union()
            .repeat(5)
            .to(0.05, { position: originalPos })
            .start();
    }
}
```

#### ImageShowcase åœºæ™¯æ­å»º

```
ImageShowcase (Node + Widget)
â”œâ”€â”€ Background (Sprite) - é‡‘è‰²è¾¹æ¡†èƒŒæ™¯
â”œâ”€â”€ ImageFrame (Node)
â”‚   â””â”€â”€ WordImage (Sprite) - å•è¯å›¾ç‰‡
â”œâ”€â”€ LoadingIndicator (Node + Animation)
â”‚   â””â”€â”€ LoadingSprite (Sprite) - æ—‹è½¬åŠ¨ç”»
â”œâ”€â”€ WordInfo (Node + Layout)
â”‚   â”œâ”€â”€ WordLabel (Label) - è‹±æ–‡å•è¯
â”‚   â””â”€â”€ PhoneticLabel (Label) - éŸ³æ ‡
â””â”€â”€ MeaningLabel (Label) - ä¸­æ–‡é‡Šä¹‰
```

**Widget ç»„ä»¶é…ç½®ï¼š**
- Align: LEFT + TOP
- Left: 20px
- Top: 100px
- Width: 200px
- Height: 200px

---

### 3.3 æ§åˆ¶é¢æ¿ï¼ˆControlPanelï¼‰

```typescript
// assets/scripts/ui/ControlPanel.ts
import { _decorator, Component, Node, Button, EditBox, Label } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('ControlPanel')
export class ControlPanel extends Component {
    @property(EditBox)
    inputBox: EditBox = null; // è¾“å…¥æ¡†
    
    @property(Label)
    previewLabel: Label = null; // å®æ—¶é¢„è§ˆ
    
    @property(Button)
    startBtn: Button = null; // å¼€å§‹æŒ‰é’®
    
    @property(Button)
    pauseBtn: Button = null; // æš‚åœæŒ‰é’®
    
    @property(Button)
    resetBtn: Button = null; // é‡ç½®æŒ‰é’®
    
    @property(Button)
    giveUpBtn: Button = null; // æ”¾å¼ƒæŒ‰é’®
    
    @property(Button)
    settingsBtn: Button = null; // è®¾ç½®æŒ‰é’®
    
    @property(Button)
    toggleSpeechBtn: Button = null; // è¯­éŸ³å¼€å…³
    
    private gameManager: any = null;
    
    /**
     * åˆå§‹åŒ–
     */
    public initialize(gameManager: any): void {
        this.gameManager = gameManager;
        this.setupButtons();
        this.setupInput();
    }
    
    /**
     * è®¾ç½®æŒ‰é’®äº‹ä»¶
     */
    private setupButtons(): void {
        // å¼€å§‹æŒ‰é’®
        this.startBtn.node.on(Button.EventType.CLICK, () => {
            this.gameManager.startGame();
            this.updateButtonStates(true);
        }, this);
        
        // æš‚åœæŒ‰é’®
        this.pauseBtn.node.on(Button.EventType.CLICK, () => {
            if (this.gameManager.isPausedState()) {
                this.gameManager.resumeGame();
                this.pauseBtn.getComponentInChildren(Label).string = 'æš‚åœ';
            } else {
                this.gameManager.pauseGame();
                this.pauseBtn.getComponentInChildren(Label).string = 'ç»§ç»­';
            }
        }, this);
        
        // é‡ç½®æŒ‰é’®
        this.resetBtn.node.on(Button.EventType.CLICK, () => {
            this.gameManager.resetGame();
            this.updateButtonStates(false);
        }, this);
        
        // æ”¾å¼ƒæŒ‰é’®
        this.giveUpBtn.node.on(Button.EventType.CLICK, () => {
            this.node.emit('give-up');
        }, this);
        
        // è®¾ç½®æŒ‰é’®
        this.settingsBtn.node.on(Button.EventType.CLICK, () => {
            this.openSettings();
        }, this);
        
        // è¯­éŸ³å¼€å…³
        this.toggleSpeechBtn.node.on(Button.EventType.CLICK, () => {
            this.toggleSpeech();
        }, this);
    }
    
    /**
     * è®¾ç½®è¾“å…¥æ¡†
     */
    private setupInput(): void {
        // è¾“å…¥æ¡†å˜åŒ–äº‹ä»¶
        this.inputBox.node.on('editing-did-changed', (editBox: EditBox) => {
            const input = editBox.string;
            this.node.emit('input-change', input);
            this.updatePreview(input);
        }, this);
        
        // è¾“å…¥å®Œæˆäº‹ä»¶
        this.inputBox.node.on('editing-return', (editBox: EditBox) => {
            const input = editBox.string;
            this.node.emit('input-complete', input);
        }, this);
    }
    
    /**
     * æ›´æ–°å®æ—¶é¢„è§ˆ
     */
    private updatePreview(input: string): void {
        // TODO: æ ¹æ®å½“å‰å•è¯æ›´æ–°é¢„è§ˆ
        this.previewLabel.string = `å®æ—¶é¢„è§ˆ: ${input}`;
    }
    
    /**
     * æ¸…ç©ºè¾“å…¥
     */
    public clearInput(): void {
        this.inputBox.string = '';
        this.previewLabel.string = 'å®æ—¶é¢„è§ˆ: ';
    }
    
    /**
     * æ›´æ–°æŒ‰é’®çŠ¶æ€
     */
    private updateButtonStates(playing: boolean): void {
        this.startBtn.interactable = !playing;
        this.pauseBtn.interactable = playing;
        this.giveUpBtn.interactable = playing;
    }
    
    /**
     * æ‰“å¼€è®¾ç½®
     */
    private openSettings(): void {
        // TODO: åŠ è½½è®¾ç½®åœºæ™¯æˆ–æ˜¾ç¤ºè®¾ç½®å¼¹çª—
        director.loadScene('Settings');
    }
    
    /**
     * åˆ‡æ¢è¯­éŸ³
     */
    private toggleSpeech(): void {
        // TODO: åˆ‡æ¢è¯­éŸ³å¼€å…³
        const label = this.toggleSpeechBtn.getComponentInChildren(Label);
        const currentState = label.string;
        
        if (currentState === 'ğŸ”Š è¯­éŸ³å¼€') {
            label.string = 'ğŸ”‡ è¯­éŸ³å…³';
        } else {
            label.string = 'ğŸ”Š è¯­éŸ³å¼€';
        }
    }
}
```

#### ControlPanel åœºæ™¯æ­å»º

```
ControlPanel (Node + Layout)
â”œâ”€â”€ InputSection (Node + Layout)
â”‚   â”œâ”€â”€ InputLabel (Label) "è¾“å…¥ç¼ºå¤±å­—æ¯:"
â”‚   â”œâ”€â”€ InputBox (EditBox)
â”‚   â”œâ”€â”€ PreviewLabel (Label) "å®æ—¶é¢„è§ˆ:"
â”‚   â””â”€â”€ GiveUpBtn (Button) "æ”¾å¼ƒ (ç©ºæ ¼é”®)"
â”‚
â”œâ”€â”€ ButtonsGroup (Node + Layout)
â”‚   â”œâ”€â”€ StartBtn (Button) "å¼€å§‹æ¸¸æˆ"
â”‚   â”œâ”€â”€ PauseBtn (Button) "æš‚åœ"
â”‚   â”œâ”€â”€ ResetBtn (Button) "é‡ç½®"
â”‚   â”œâ”€â”€ SettingsBtn (Button) "âš™ï¸ è¯åº“è®¾ç½®"
â”‚   â”œâ”€â”€ ToggleSpeechBtn (Button) "ğŸ”Š è¯­éŸ³å¼€"
â”‚   â””â”€â”€ TestBtn (Button) "ğŸ§ª å•æµ‹"
â”‚
â””â”€â”€ KeyboardHint (Label) "ğŸ’¡ ç›´æ¥æŒ‰é”®ç›˜å­—æ¯é”®è¾“å…¥..."
```

**Layout ç»„ä»¶é…ç½®ï¼š**
- Type: VERTICALï¼ˆå‚ç›´å¸ƒå±€ï¼‰
- Spacing: 15ï¼ˆé—´è·ï¼‰
- Padding: 20ï¼ˆå†…è¾¹è·ï¼‰

---

### 3.4 ç”Ÿè¯æœ¬ï¼ˆVocabularyBookï¼‰

```typescript
// assets/scripts/ui/VocabularyBook.ts
import { _decorator, Component, Node, Label, ScrollView, Prefab, 
         instantiate, Button } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('VocabularyBook')
export class VocabularyBook extends Component {
    @property(Label)
    titleLabel: Label = null; // æ ‡é¢˜ï¼ˆæ˜¾ç¤ºæ•°é‡ï¼‰
    
    @property(ScrollView)
    scrollView: ScrollView = null; // æ»šåŠ¨è§†å›¾
    
    @property(Node)
    content: Node = null; // å†…å®¹å®¹å™¨
    
    @property(Prefab)
    vocabItemPrefab: Prefab = null; // å•è¯é¡¹é¢„åˆ¶ä½“
    
    @property(Button)
    exportBtn: Button = null; // å¯¼å‡ºæŒ‰é’®
    
    private missedWords: string[] = [];
    
    /**
     * åˆå§‹åŒ–
     */
    public initialize(): void {
        this.exportBtn.node.on(Button.EventType.CLICK, this.exportVocabulary, this);
        this.updateTitle();
    }
    
    /**
     * æ·»åŠ ç”Ÿè¯
     */
    public addWord(word: string, phonetic: string, meaning: string): void {
        // é¿å…é‡å¤
        if (this.missedWords.includes(word)) {
            return;
        }
        
        this.missedWords.push(word);
        
        // åˆ›å»ºå•è¯é¡¹
        const item = instantiate(this.vocabItemPrefab);
        this.content.addChild(item);
        
        // è®¾ç½®æ•°æ®
        const wordLabel = item.getChildByName('WordLabel').getComponent(Label);
        const phoneticLabel = item.getChildByName('PhoneticLabel').getComponent(Label);
        const meaningLabel = item.getChildByName('MeaningLabel').getComponent(Label);
        
        wordLabel.string = word;
        phoneticLabel.string = phonetic;
        meaningLabel.string = meaning;
        
        // æ›´æ–°æ ‡é¢˜
        this.updateTitle();
        
        // æ»šåŠ¨åˆ°åº•éƒ¨
        this.scrollToBottom();
    }
    
    /**
     * æ¸…ç©ºç”Ÿè¯æœ¬
     */
    public clear(): void {
        this.missedWords = [];
        this.content.removeAllChildren();
        this.updateTitle();
    }
    
    /**
     * æ›´æ–°æ ‡é¢˜
     */
    private updateTitle(): void {
        this.titleLabel.string = `ç”Ÿè¯æœ¬ (${this.missedWords.length})`;
        
        // æ›´æ–°å¯¼å‡ºæŒ‰é’®çŠ¶æ€
        this.exportBtn.interactable = this.missedWords.length > 0;
    }
    
    /**
     * æ»šåŠ¨åˆ°åº•éƒ¨
     */
    private scrollToBottom(): void {
        this.scheduleOnce(() => {
            this.scrollView.scrollToBottom(0.5);
        }, 0.1);
    }
    
    /**
     * å¯¼å‡ºç”Ÿè¯æœ¬
     */
    private exportVocabulary(): void {
        if (this.missedWords.length === 0) {
            return;
        }
        
        // ç”Ÿæˆæ–‡æœ¬å†…å®¹
        let content = 'å•è¯, éŸ³æ ‡, ä¸­æ–‡ç¿»è¯‘\n';
        
        for (let i = 0; i < this.content.children.length; i++) {
            const item = this.content.children[i];
            const word = item.getChildByName('WordLabel').getComponent(Label).string;
            const phonetic = item.getChildByName('PhoneticLabel').getComponent(Label).string;
            const meaning = item.getChildByName('MeaningLabel').getComponent(Label).string;
            
            content += `${word}, ${phonetic}, ${meaning}\n`;
        }
        
        // ä¸‹è½½æ–‡ä»¶ï¼ˆWebå¹³å°ï¼‰
        if (sys.isBrowser) {
            this.downloadFile('missed_words.txt', content);
        }
        
        console.log('ç”Ÿè¯æœ¬å¯¼å‡º:', content);
    }
    
    /**
     * ä¸‹è½½æ–‡ä»¶
     */
    private downloadFile(filename: string, content: string): void {
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        
        URL.revokeObjectURL(url);
    }
}
```

#### VocabularyBook åœºæ™¯æ­å»º

```
VocabularyBook (Node + Widget)
â”œâ”€â”€ TitleLabel (Label) "ç”Ÿè¯æœ¬ (0)"
â”œâ”€â”€ ScrollView (ScrollView)
â”‚   â””â”€â”€ view (Node)
â”‚       â””â”€â”€ content (Node + Layout)
â”‚           â””â”€â”€ [åŠ¨æ€åˆ›å»ºçš„ VocabItem]
â””â”€â”€ ExportBtn (Button) "å¯¼å‡ºç”Ÿè¯"
```

**VocabItem é¢„åˆ¶ä½“ï¼š**
```
VocabItem (Node + Layout)
â”œâ”€â”€ WordLabel (Label) - å•è¯
â”œâ”€â”€ PhoneticLabel (Label) - éŸ³æ ‡
â””â”€â”€ MeaningLabel (Label) - ä¸­æ–‡
```

---

### 3.5 å¼¹çª—ç³»ç»Ÿï¼ˆModalï¼‰

```typescript
// assets/scripts/ui/Modal.ts
import { _decorator, Component, Node, Label, Button, BlockInputEvents } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('Modal')
export class Modal extends Component {
    @property(Node)
    overlay: Node = null; // é®ç½©å±‚
    
    @property(Node)
    container: Node = null; // å¼¹çª—å®¹å™¨
    
    @property(Label)
    titleLabel: Label = null; // æ ‡é¢˜
    
    @property(Label)
    messageLabel: Label = null; // æ¶ˆæ¯
    
    @property(Node)
    buttonsContainer: Node = null; // æŒ‰é’®å®¹å™¨
    
    /**
     * æ˜¾ç¤ºå¼¹çª—
     */
    public show(title: string, message: string, buttons: ModalButton[]): void {
        this.node.active = true;
        
        // è®¾ç½®å†…å®¹
        this.titleLabel.string = title;
        this.messageLabel.string = message;
        
        // æ¸…ç©ºæŒ‰é’®
        this.buttonsContainer.removeAllChildren();
        
        // åˆ›å»ºæŒ‰é’®
        for (const btnConfig of buttons) {
            const btn = this.createButton(btnConfig);
            this.buttonsContainer.addChild(btn);
        }
        
        // æ’­æ”¾æ˜¾ç¤ºåŠ¨ç”»
        this.playShowAnimation();
    }
    
    /**
     * éšè—å¼¹çª—
     */
    public hide(): void {
        this.playHideAnimation(() => {
            this.node.active = false;
        });
    }
    
    /**
     * åˆ›å»ºæŒ‰é’®
     */
    private createButton(config: ModalButton): Node {
        const btn = new Node('Button');
        const button = btn.addComponent(Button);
        const label = new Node('Label');
        label.parent = btn;
        const labelComp = label.addComponent(Label);
        
        labelComp.string = config.text;
        
        btn.on(Button.EventType.CLICK, () => {
            if (config.callback) {
                config.callback();
            }
            if (config.closeOnClick !== false) {
                this.hide();
            }
        }, this);
        
        return btn;
    }
    
    /**
     * æ˜¾ç¤ºåŠ¨ç”»
     */
    private playShowAnimation(): void {
        this.container.setScale(0.5, 0.5, 1);
        
        tween(this.container)
            .to(0.3, { scale: new Vec3(1, 1, 1) }, { easing: 'backOut' })
            .start();
        
        const uiOpacity = this.overlay.addComponent(UIOpacity);
        uiOpacity.opacity = 0;
        
        tween(uiOpacity)
            .to(0.3, { opacity: 200 })
            .start();
    }
    
    /**
     * éšè—åŠ¨ç”»
     */
    private playHideAnimation(callback: () => void): void {
        tween(this.container)
            .to(0.2, { scale: new Vec3(0, 0, 1) })
            .call(callback)
            .start();
    }
}

/**
 * æŒ‰é’®é…ç½®æ¥å£
 */
interface ModalButton {
    text: string;
    callback?: () => void;
    closeOnClick?: boolean;
}
```

---

## 4ï¸âƒ£ å“åº”å¼å¸ƒå±€

### 4.1 Widget ç»„ä»¶ä½¿ç”¨

```typescript
// å¯¹é½åˆ°å·¦ä¸Šè§’
widget.isAlignLeft = true;
widget.isAlignTop = true;
widget.left = 20;
widget.top = 20;

// å¯¹é½åˆ°å³ä¸‹è§’
widget.isAlignRight = true;
widget.isAlignBottom = true;
widget.right = 20;
widget.bottom = 20;

// æ‹‰ä¼¸åˆ°å…¨å±
widget.isAlignLeft = true;
widget.isAlignRight = true;
widget.isAlignTop = true;
widget.isAlignBottom = true;
widget.left = 0;
widget.right = 0;
widget.top = 0;
widget.bottom = 0;
```

### 4.2 Layout ç»„ä»¶ä½¿ç”¨

```typescript
// æ°´å¹³å¸ƒå±€
layout.type = Layout.Type.HORIZONTAL;
layout.spacingX = 10; // é—´è·
layout.paddingLeft = 20; // å†…è¾¹è·

// å‚ç›´å¸ƒå±€
layout.type = Layout.Type.VERTICAL;
layout.spacingY = 10;

// ç½‘æ ¼å¸ƒå±€
layout.type = Layout.Type.GRID;
layout.spacingX = 10;
layout.spacingY = 10;
```

---

## 5ï¸âƒ£ äº‹ä»¶ç³»ç»Ÿ

### 5.1 æŒ‰é’®äº‹ä»¶

```typescript
// ç‚¹å‡»äº‹ä»¶
button.node.on(Button.EventType.CLICK, () => {
    console.log('æŒ‰é’®è¢«ç‚¹å‡»');
}, this);

// æŒ‰ä¸‹/æŠ¬èµ·äº‹ä»¶
button.node.on(Node.EventType.TOUCH_START, (event) => {
    console.log('è§¦æ‘¸å¼€å§‹');
}, this);

button.node.on(Node.EventType.TOUCH_END, (event) => {
    console.log('è§¦æ‘¸ç»“æŸ');
}, this);
```

### 5.2 è‡ªå®šä¹‰äº‹ä»¶

```typescript
// å‘é€äº‹ä»¶
this.node.emit('custom-event', data);

// ç›‘å¬äº‹ä»¶
this.node.on('custom-event', (data) => {
    console.log('æ”¶åˆ°äº‹ä»¶:', data);
}, this);

// ç§»é™¤äº‹ä»¶
this.node.off('custom-event', callback, this);
```

---

## 6ï¸âƒ£ éªŒè¯æ¸…å•

- [ ] é¡¶éƒ¨ä¿¡æ¯æ æ˜¾ç¤ºæ­£ç¡®
- [ ] å›¾ç‰‡å±•ç¤ºåŒºåŠ è½½æ­£å¸¸
- [ ] æ§åˆ¶é¢æ¿æŒ‰é’®å¯ç”¨
- [ ] è¾“å…¥æ¡†å“åº”æ­£å¸¸
- [ ] ç”Ÿè¯æœ¬æ»šåŠ¨æµç•…
- [ ] å¼¹çª—æ˜¾ç¤ºæ­£ç¡®
- [ ] å¸ƒå±€è‡ªé€‚åº”ä¸åŒåˆ†è¾¨ç‡
- [ ] æ‰€æœ‰æŒ‰é’®ç‚¹å‡»æœ‰æ•ˆ
- [ ] æ–‡å­—å¤§å°åˆé€‚
- [ ] UI å±‚çº§æ­£ç¡®

---

**UI ç³»ç»Ÿé‡å»ºå®Œæˆï¼** âœ…

ä¸‹ä¸€æ­¥ï¼šé˜…è¯» [08_éŸ³é¢‘ç³»ç»Ÿé€‚é….md](./08_éŸ³é¢‘ç³»ç»Ÿé€‚é….md)

