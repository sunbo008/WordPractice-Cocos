# UI 系统重建

## 📋 本文档内容

- HTML DOM 到 Cocos UI 组件转换
- 界面布局实现
- 交互逻辑重建
- 响应式适配

---

## 1️⃣ UI 系统对比

### 1.1 HTML DOM vs Cocos UI

| UI 元素 | HTML DOM | Cocos Creator |
|---------|----------|---------------|
| **按钮** | `<button>` | `cc.Button` 组件 |
| **输入框** | `<input>` | `cc.EditBox` 组件 |
| **文本** | `<div>`, `<span>` | `cc.Label` 组件 |
| **图片** | `<img>` | `cc.Sprite` 组件 |
| **容器** | `<div>` | `cc.Node` + Layout |
| **滚动** | `overflow: scroll` | `cc.ScrollView` 组件 |
| **布局** | CSS Flexbox/Grid | `cc.Layout` 组件 |
| **对齐** | CSS position | `cc.Widget` 组件 |
| **事件** | `addEventListener` | `node.on(EVENT_TYPE)` |

---

## 2️⃣ 主界面布局实现

### 2.1 Canvas 根节点设置

```typescript
// 场景中的 Canvas 节点配置
Canvas 属性检查器：
- Design Resolution: 1280 x 720
- Fit Height: true
- Fit Width: true
```

### 2.2 三栏布局结构

根据设计文档，实现三栏布局：**图片展示区 + 游戏画布 + 侧边栏**

```
Canvas (根节点)
├── Camera (相机)
│
├── GameLayer (游戏层)
│   └── ... (游戏内容)
│
└── UILayer (UI层)
    ├── TopBar (顶部信息栏)
    ├── ExamStats (考试统计栏)
    ├── LeftPanel (左侧面板)
    │   ├── ImageShowcase (图片展示区)
    │   └── ControlPanel (控制面板)
    └── Sidebar (右侧边栏)
        ├── BufferIndicator (缓冲区指示)
        ├── VocabularyBook (生词本)
        └── Instructions (游戏说明)
```

---

## 3️⃣ UI 组件实现

### 3.1 顶部信息栏（TopBar）

```typescript
// assets/scripts/ui/TopBar.ts
import { _decorator, Component, Node, Label } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('TopBar')
export class TopBar extends Component {
    // 信息标签
    @property(Label)
    scoreLabel: Label = null;
    
    @property(Label)
    levelLabel: Label = null;
    
    @property(Label)
    targetLabel: Label = null;
    
    @property(Label)
    vocabCountLabel: Label = null;
    
    @property(Label)
    timeLabel: Label = null;
    
    @property(Label)
    comboLabel: Label = null;
    
    /**
     * 更新分数显示
     */
    public updateScore(score: number): void {
        this.scoreLabel.string = score.toString();
    }
    
    /**
     * 更新等级显示
     */
    public updateLevel(level: number): void {
        this.levelLabel.string = level.toString();
    }
    
    /**
     * 更新目标分数
     */
    public updateTarget(target: number): void {
        this.targetLabel.string = target.toString();
    }
    
    /**
     * 更新单词总数
     */
    public updateVocabCount(count: number): void {
        this.vocabCountLabel.string = count.toString();
    }
    
    /**
     * 更新时间显示
     */
    public updateTime(seconds: number): void {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        this.timeLabel.string = `${this.pad(minutes)}:${this.pad(secs)}`;
    }
    
    /**
     * 更新连击数
     */
    public updateCombo(combo: number): void {
        this.comboLabel.string = combo.toString();
        
        // 连击数大于3时高亮显示
        if (combo >= 3) {
            this.comboLabel.color = new Color(255, 215, 0); // 金黄色
            this.playScaleAnimation(this.comboLabel.node);
        } else {
            this.comboLabel.color = Color.WHITE;
        }
    }
    
    /**
     * 数字补零
     */
    private pad(num: number): string {
        return num < 10 ? '0' + num : num.toString();
    }
    
    /**
     * 播放缩放动画
     */
    private playScaleAnimation(node: Node): void {
        tween(node)
            .to(0.1, { scale: new Vec3(1.2, 1.2, 1) })
            .to(0.1, { scale: new Vec3(1.0, 1.0, 1) })
            .start();
    }
}
```

#### TopBar 场景搭建

```
TopBar (Node + Layout)
├── ScoreItem (Node + Layout)
│   ├── Label_Score (Label) "分数:"
│   └── Value_Score (Label) "0"
├── LevelItem (Node + Layout)
│   ├── Label_Level (Label) "等级:"
│   └── Value_Level (Label) "1"
├── TargetItem (Node + Layout)
│   ├── Label_Target (Label) "目标:"
│   └── Value_Target (Label) "100"
├── VocabItem (Node + Layout)
│   ├── Label_Vocab (Label) "单词总数:"
│   └── Value_Vocab (Label) "0"
├── TimeItem (Node + Layout)
│   ├── Label_Time (Label) "时间:"
│   └── Value_Time (Label) "00:00"
└── ComboItem (Node + Layout)
    ├── Label_Combo (Label) "连击:"
    └── Value_Combo (Label) "0"
```

**Layout 组件配置：**
- Type: HORIZONTAL（水平布局）
- Resize Mode: CONTAINER（容器自适应）
- Spacing: 20（间距）
- Padding: 10（内边距）

---

### 3.2 图片展示区（ImageShowcase）

```typescript
// assets/scripts/ui/ImageShowcase.ts
import { _decorator, Component, Node, Sprite, Label, SpriteFrame, 
         resources, tween, Vec3 } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('ImageShowcase')
export class ImageShowcase extends Component {
    @property(Sprite)
    wordImage: Sprite = null; // 单词图片
    
    @property(Label)
    wordLabel: Label = null; // 英文单词
    
    @property(Label)
    phoneticLabel: Label = null; // 音标
    
    @property(Label)
    meaningLabel: Label = null; // 中文释义
    
    @property(Node)
    loadingIndicator: Node = null; // 加载指示器
    
    private currentWord: string = '';
    
    /**
     * 更新单词显示
     */
    public async updateWord(word: string, phonetic: string, meaning: string): Promise<void> {
        if (this.currentWord === word) {
            return; // 相同单词，不重复加载
        }
        
        this.currentWord = word;
        
        // 更新文字信息
        this.wordLabel.string = word.toLowerCase();
        this.phoneticLabel.string = phonetic;
        this.meaningLabel.string = meaning;
        
        // 加载图片
        await this.loadImage(word);
    }
    
    /**
     * 加载单词图片
     */
    private async loadImage(word: string): Promise<void> {
        // 显示加载指示器
        this.showLoading(true);
        
        try {
            // 1. 尝试从本地资源加载
            const localFrame = await this.loadLocalImage(word);
            if (localFrame) {
                this.wordImage.spriteFrame = localFrame;
                this.playFadeInAnimation();
                this.showLoading(false);
                return;
            }
            
            // 2. 尝试从网络加载
            const remoteFrame = await this.loadRemoteImage(word);
            if (remoteFrame) {
                this.wordImage.spriteFrame = remoteFrame;
                this.playFadeInAnimation();
                this.showLoading(false);
                return;
            }
            
            // 3. 显示占位符
            this.showPlaceholder(word);
            this.showLoading(false);
            
        } catch (error) {
            console.error('加载图片失败:', error);
            this.showPlaceholder(word);
            this.showLoading(false);
        }
    }
    
    /**
     * 加载本地图片
     */
    private loadLocalImage(word: string): Promise<SpriteFrame> {
        return new Promise((resolve, reject) => {
            const path = `images/words/${word}`;
            resources.load(path, SpriteFrame, (err, frame) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(frame);
                }
            });
        });
    }
    
    /**
     * 加载网络图片
     */
    private loadRemoteImage(word: string): Promise<SpriteFrame> {
        return new Promise((resolve, reject) => {
            const url = `https://source.unsplash.com/200x200/?${word}`;
            
            assetManager.loadRemote(url, (err, texture: Texture2D) => {
                if (err) {
                    reject(err);
                } else {
                    const frame = new SpriteFrame();
                    frame.texture = texture;
                    resolve(frame);
                }
            });
        });
    }
    
    /**
     * 显示占位符
     */
    private showPlaceholder(word: string): void {
        // 显示首字母大写
        const placeholder = word[0].toUpperCase();
        
        // 创建占位符纹理（使用 Graphics）
        // TODO: 实现占位符生成
    }
    
    /**
     * 显示/隐藏加载指示器
     */
    private showLoading(show: boolean): void {
        if (this.loadingIndicator) {
            this.loadingIndicator.active = show;
        }
    }
    
    /**
     * 淡入动画
     */
    private playFadeInAnimation(): void {
        const uiOpacity = this.wordImage.node.getComponent(UIOpacity) || 
                         this.wordImage.node.addComponent(UIOpacity);
        
        uiOpacity.opacity = 0;
        
        tween(uiOpacity)
            .to(0.5, { opacity: 255 })
            .start();
    }
    
    /**
     * 成功闪烁动画
     */
    public playSuccessAnimation(): void {
        const originalColor = this.wordImage.color.clone();
        const greenColor = new Color(76, 175, 80);
        
        tween(this.wordImage)
            .to(0.2, { color: greenColor })
            .to(0.2, { color: originalColor })
            .union()
            .repeat(3)
            .start();
    }
    
    /**
     * 错误抖动动画
     */
    public playErrorAnimation(): void {
        const originalPos = this.node.position.clone();
        
        tween(this.node)
            .to(0.05, { position: new Vec3(originalPos.x + 5, originalPos.y, 0) })
            .to(0.05, { position: new Vec3(originalPos.x - 5, originalPos.y, 0) })
            .union()
            .repeat(5)
            .to(0.05, { position: originalPos })
            .start();
    }
}
```

#### ImageShowcase 场景搭建

```
ImageShowcase (Node + Widget)
├── Background (Sprite) - 金色边框背景
├── ImageFrame (Node)
│   └── WordImage (Sprite) - 单词图片
├── LoadingIndicator (Node + Animation)
│   └── LoadingSprite (Sprite) - 旋转动画
├── WordInfo (Node + Layout)
│   ├── WordLabel (Label) - 英文单词
│   └── PhoneticLabel (Label) - 音标
└── MeaningLabel (Label) - 中文释义
```

**Widget 组件配置：**
- Align: LEFT + TOP
- Left: 20px
- Top: 100px
- Width: 200px
- Height: 200px

---

### 3.3 控制面板（ControlPanel）

```typescript
// assets/scripts/ui/ControlPanel.ts
import { _decorator, Component, Node, Button, EditBox, Label } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('ControlPanel')
export class ControlPanel extends Component {
    @property(EditBox)
    inputBox: EditBox = null; // 输入框
    
    @property(Label)
    previewLabel: Label = null; // 实时预览
    
    @property(Button)
    startBtn: Button = null; // 开始按钮
    
    @property(Button)
    pauseBtn: Button = null; // 暂停按钮
    
    @property(Button)
    resetBtn: Button = null; // 重置按钮
    
    @property(Button)
    giveUpBtn: Button = null; // 放弃按钮
    
    @property(Button)
    settingsBtn: Button = null; // 设置按钮
    
    @property(Button)
    toggleSpeechBtn: Button = null; // 语音开关
    
    private gameManager: any = null;
    
    /**
     * 初始化
     */
    public initialize(gameManager: any): void {
        this.gameManager = gameManager;
        this.setupButtons();
        this.setupInput();
    }
    
    /**
     * 设置按钮事件
     */
    private setupButtons(): void {
        // 开始按钮
        this.startBtn.node.on(Button.EventType.CLICK, () => {
            this.gameManager.startGame();
            this.updateButtonStates(true);
        }, this);
        
        // 暂停按钮
        this.pauseBtn.node.on(Button.EventType.CLICK, () => {
            if (this.gameManager.isPausedState()) {
                this.gameManager.resumeGame();
                this.pauseBtn.getComponentInChildren(Label).string = '暂停';
            } else {
                this.gameManager.pauseGame();
                this.pauseBtn.getComponentInChildren(Label).string = '继续';
            }
        }, this);
        
        // 重置按钮
        this.resetBtn.node.on(Button.EventType.CLICK, () => {
            this.gameManager.resetGame();
            this.updateButtonStates(false);
        }, this);
        
        // 放弃按钮
        this.giveUpBtn.node.on(Button.EventType.CLICK, () => {
            this.node.emit('give-up');
        }, this);
        
        // 设置按钮
        this.settingsBtn.node.on(Button.EventType.CLICK, () => {
            this.openSettings();
        }, this);
        
        // 语音开关
        this.toggleSpeechBtn.node.on(Button.EventType.CLICK, () => {
            this.toggleSpeech();
        }, this);
    }
    
    /**
     * 设置输入框
     */
    private setupInput(): void {
        // 输入框变化事件
        this.inputBox.node.on('editing-did-changed', (editBox: EditBox) => {
            const input = editBox.string;
            this.node.emit('input-change', input);
            this.updatePreview(input);
        }, this);
        
        // 输入完成事件
        this.inputBox.node.on('editing-return', (editBox: EditBox) => {
            const input = editBox.string;
            this.node.emit('input-complete', input);
        }, this);
    }
    
    /**
     * 更新实时预览
     */
    private updatePreview(input: string): void {
        // TODO: 根据当前单词更新预览
        this.previewLabel.string = `实时预览: ${input}`;
    }
    
    /**
     * 清空输入
     */
    public clearInput(): void {
        this.inputBox.string = '';
        this.previewLabel.string = '实时预览: ';
    }
    
    /**
     * 更新按钮状态
     */
    private updateButtonStates(playing: boolean): void {
        this.startBtn.interactable = !playing;
        this.pauseBtn.interactable = playing;
        this.giveUpBtn.interactable = playing;
    }
    
    /**
     * 打开设置
     */
    private openSettings(): void {
        // TODO: 加载设置场景或显示设置弹窗
        director.loadScene('Settings');
    }
    
    /**
     * 切换语音
     */
    private toggleSpeech(): void {
        // TODO: 切换语音开关
        const label = this.toggleSpeechBtn.getComponentInChildren(Label);
        const currentState = label.string;
        
        if (currentState === '🔊 语音开') {
            label.string = '🔇 语音关';
        } else {
            label.string = '🔊 语音开';
        }
    }
}
```

#### ControlPanel 场景搭建

```
ControlPanel (Node + Layout)
├── InputSection (Node + Layout)
│   ├── InputLabel (Label) "输入缺失字母:"
│   ├── InputBox (EditBox)
│   ├── PreviewLabel (Label) "实时预览:"
│   └── GiveUpBtn (Button) "放弃 (空格键)"
│
├── ButtonsGroup (Node + Layout)
│   ├── StartBtn (Button) "开始游戏"
│   ├── PauseBtn (Button) "暂停"
│   ├── ResetBtn (Button) "重置"
│   ├── SettingsBtn (Button) "⚙️ 词库设置"
│   ├── ToggleSpeechBtn (Button) "🔊 语音开"
│   └── TestBtn (Button) "🧪 单测"
│
└── KeyboardHint (Label) "💡 直接按键盘字母键输入..."
```

**Layout 组件配置：**
- Type: VERTICAL（垂直布局）
- Spacing: 15（间距）
- Padding: 20（内边距）

---

### 3.4 生词本（VocabularyBook）

```typescript
// assets/scripts/ui/VocabularyBook.ts
import { _decorator, Component, Node, Label, ScrollView, Prefab, 
         instantiate, Button } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('VocabularyBook')
export class VocabularyBook extends Component {
    @property(Label)
    titleLabel: Label = null; // 标题（显示数量）
    
    @property(ScrollView)
    scrollView: ScrollView = null; // 滚动视图
    
    @property(Node)
    content: Node = null; // 内容容器
    
    @property(Prefab)
    vocabItemPrefab: Prefab = null; // 单词项预制体
    
    @property(Button)
    exportBtn: Button = null; // 导出按钮
    
    private missedWords: string[] = [];
    
    /**
     * 初始化
     */
    public initialize(): void {
        this.exportBtn.node.on(Button.EventType.CLICK, this.exportVocabulary, this);
        this.updateTitle();
    }
    
    /**
     * 添加生词
     */
    public addWord(word: string, phonetic: string, meaning: string): void {
        // 避免重复
        if (this.missedWords.includes(word)) {
            return;
        }
        
        this.missedWords.push(word);
        
        // 创建单词项
        const item = instantiate(this.vocabItemPrefab);
        this.content.addChild(item);
        
        // 设置数据
        const wordLabel = item.getChildByName('WordLabel').getComponent(Label);
        const phoneticLabel = item.getChildByName('PhoneticLabel').getComponent(Label);
        const meaningLabel = item.getChildByName('MeaningLabel').getComponent(Label);
        
        wordLabel.string = word;
        phoneticLabel.string = phonetic;
        meaningLabel.string = meaning;
        
        // 更新标题
        this.updateTitle();
        
        // 滚动到底部
        this.scrollToBottom();
    }
    
    /**
     * 清空生词本
     */
    public clear(): void {
        this.missedWords = [];
        this.content.removeAllChildren();
        this.updateTitle();
    }
    
    /**
     * 更新标题
     */
    private updateTitle(): void {
        this.titleLabel.string = `生词本 (${this.missedWords.length})`;
        
        // 更新导出按钮状态
        this.exportBtn.interactable = this.missedWords.length > 0;
    }
    
    /**
     * 滚动到底部
     */
    private scrollToBottom(): void {
        this.scheduleOnce(() => {
            this.scrollView.scrollToBottom(0.5);
        }, 0.1);
    }
    
    /**
     * 导出生词本
     */
    private exportVocabulary(): void {
        if (this.missedWords.length === 0) {
            return;
        }
        
        // 生成文本内容
        let content = '单词, 音标, 中文翻译\n';
        
        for (let i = 0; i < this.content.children.length; i++) {
            const item = this.content.children[i];
            const word = item.getChildByName('WordLabel').getComponent(Label).string;
            const phonetic = item.getChildByName('PhoneticLabel').getComponent(Label).string;
            const meaning = item.getChildByName('MeaningLabel').getComponent(Label).string;
            
            content += `${word}, ${phonetic}, ${meaning}\n`;
        }
        
        // 下载文件（Web平台）
        if (sys.isBrowser) {
            this.downloadFile('missed_words.txt', content);
        }
        
        console.log('生词本导出:', content);
    }
    
    /**
     * 下载文件
     */
    private downloadFile(filename: string, content: string): void {
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        
        URL.revokeObjectURL(url);
    }
}
```

#### VocabularyBook 场景搭建

```
VocabularyBook (Node + Widget)
├── TitleLabel (Label) "生词本 (0)"
├── ScrollView (ScrollView)
│   └── view (Node)
│       └── content (Node + Layout)
│           └── [动态创建的 VocabItem]
└── ExportBtn (Button) "导出生词"
```

**VocabItem 预制体：**
```
VocabItem (Node + Layout)
├── WordLabel (Label) - 单词
├── PhoneticLabel (Label) - 音标
└── MeaningLabel (Label) - 中文
```

---

### 3.5 弹窗系统（Modal）

```typescript
// assets/scripts/ui/Modal.ts
import { _decorator, Component, Node, Label, Button, BlockInputEvents } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('Modal')
export class Modal extends Component {
    @property(Node)
    overlay: Node = null; // 遮罩层
    
    @property(Node)
    container: Node = null; // 弹窗容器
    
    @property(Label)
    titleLabel: Label = null; // 标题
    
    @property(Label)
    messageLabel: Label = null; // 消息
    
    @property(Node)
    buttonsContainer: Node = null; // 按钮容器
    
    /**
     * 显示弹窗
     */
    public show(title: string, message: string, buttons: ModalButton[]): void {
        this.node.active = true;
        
        // 设置内容
        this.titleLabel.string = title;
        this.messageLabel.string = message;
        
        // 清空按钮
        this.buttonsContainer.removeAllChildren();
        
        // 创建按钮
        for (const btnConfig of buttons) {
            const btn = this.createButton(btnConfig);
            this.buttonsContainer.addChild(btn);
        }
        
        // 播放显示动画
        this.playShowAnimation();
    }
    
    /**
     * 隐藏弹窗
     */
    public hide(): void {
        this.playHideAnimation(() => {
            this.node.active = false;
        });
    }
    
    /**
     * 创建按钮
     */
    private createButton(config: ModalButton): Node {
        const btn = new Node('Button');
        const button = btn.addComponent(Button);
        const label = new Node('Label');
        label.parent = btn;
        const labelComp = label.addComponent(Label);
        
        labelComp.string = config.text;
        
        btn.on(Button.EventType.CLICK, () => {
            if (config.callback) {
                config.callback();
            }
            if (config.closeOnClick !== false) {
                this.hide();
            }
        }, this);
        
        return btn;
    }
    
    /**
     * 显示动画
     */
    private playShowAnimation(): void {
        this.container.setScale(0.5, 0.5, 1);
        
        tween(this.container)
            .to(0.3, { scale: new Vec3(1, 1, 1) }, { easing: 'backOut' })
            .start();
        
        const uiOpacity = this.overlay.addComponent(UIOpacity);
        uiOpacity.opacity = 0;
        
        tween(uiOpacity)
            .to(0.3, { opacity: 200 })
            .start();
    }
    
    /**
     * 隐藏动画
     */
    private playHideAnimation(callback: () => void): void {
        tween(this.container)
            .to(0.2, { scale: new Vec3(0, 0, 1) })
            .call(callback)
            .start();
    }
}

/**
 * 按钮配置接口
 */
interface ModalButton {
    text: string;
    callback?: () => void;
    closeOnClick?: boolean;
}
```

---

## 4️⃣ 响应式布局

### 4.1 Widget 组件使用

```typescript
// 对齐到左上角
widget.isAlignLeft = true;
widget.isAlignTop = true;
widget.left = 20;
widget.top = 20;

// 对齐到右下角
widget.isAlignRight = true;
widget.isAlignBottom = true;
widget.right = 20;
widget.bottom = 20;

// 拉伸到全屏
widget.isAlignLeft = true;
widget.isAlignRight = true;
widget.isAlignTop = true;
widget.isAlignBottom = true;
widget.left = 0;
widget.right = 0;
widget.top = 0;
widget.bottom = 0;
```

### 4.2 Layout 组件使用

```typescript
// 水平布局
layout.type = Layout.Type.HORIZONTAL;
layout.spacingX = 10; // 间距
layout.paddingLeft = 20; // 内边距

// 垂直布局
layout.type = Layout.Type.VERTICAL;
layout.spacingY = 10;

// 网格布局
layout.type = Layout.Type.GRID;
layout.spacingX = 10;
layout.spacingY = 10;
```

---

## 5️⃣ 事件系统

### 5.1 按钮事件

```typescript
// 点击事件
button.node.on(Button.EventType.CLICK, () => {
    console.log('按钮被点击');
}, this);

// 按下/抬起事件
button.node.on(Node.EventType.TOUCH_START, (event) => {
    console.log('触摸开始');
}, this);

button.node.on(Node.EventType.TOUCH_END, (event) => {
    console.log('触摸结束');
}, this);
```

### 5.2 自定义事件

```typescript
// 发送事件
this.node.emit('custom-event', data);

// 监听事件
this.node.on('custom-event', (data) => {
    console.log('收到事件:', data);
}, this);

// 移除事件
this.node.off('custom-event', callback, this);
```

---

## 6️⃣ 验证清单

- [ ] 顶部信息栏显示正确
- [ ] 图片展示区加载正常
- [ ] 控制面板按钮可用
- [ ] 输入框响应正常
- [ ] 生词本滚动流畅
- [ ] 弹窗显示正确
- [ ] 布局自适应不同分辨率
- [ ] 所有按钮点击有效
- [ ] 文字大小合适
- [ ] UI 层级正确

---

**UI 系统重建完成！** ✅

下一步：阅读 [08_音频系统适配.md](./08_音频系统适配.md)

