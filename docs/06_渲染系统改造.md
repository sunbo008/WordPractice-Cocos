# 渲染系统改造

## 📋 本文档内容

- Canvas 2D 到 Cocos 节点系统转换
- 炮管系统完整实现
- 粒子效果系统
- 动画系统实现

---

## 1️⃣ 渲染系统对比

### 1.1 Canvas 2D vs Cocos 节点系统

| 特性 | Canvas 2D | Cocos Creator |
|------|-----------|---------------|
| **绘制方式** | 手动调用绘制 API | 自动渲染节点树 |
| **坐标系统** | 左上角原点，Y向下 | 可配置锚点，Y向上 |
| **图层管理** | 手动控制绘制顺序 | z-index 自动排序 |
| **性能优化** | 手动脏矩形检测 | 引擎自动批处理 |
| **旋转缩放** | 手动矩阵变换 | `node.angle/scale` |
| **透明度** | `globalAlpha` | `node.opacity` |
| **颜色混合** | `globalCompositeOperation` | 材质系统 |

### 1.2 Canvas 绘制代码示例（原版）

```javascript
// proj/src/systems/GameRenderer.js
drawCannon() {
    const ctx = this.ctx;
    
    ctx.save();
    ctx.translate(this.cannonX, this.cannonY);
    ctx.rotate(this.cannonAngle);
    
    // 绘制炮管
    ctx.fillStyle = '#4A5F7F';
    ctx.fillRect(-10, -50, 20, 50);
    
    // 绘制炮口
    ctx.fillStyle = '#3498DB';
    ctx.beginPath();
    ctx.arc(0, -50, 15, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
}

drawWord(word) {
    const ctx = this.ctx;
    
    // 绘制背景
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(word.x - 50, word.y - 20, 100, 40);
    
    // 绘制文字
    ctx.fillStyle = 'white';
    ctx.font = '32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(word.text, word.x, word.y);
}

drawParticles() {
    for (const particle of this.particles) {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = particle.alpha;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1.0;
}
```

---

## 2️⃣ Cocos 节点系统实现

### 2.1 单词实体渲染

```typescript
// assets/scripts/entities/WordEntity.ts
import { _decorator, Component, Node, Label, Sprite, Color, UIOpacity } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('WordEntity')
export class WordEntity extends Component {
    @property(Node)
    background: Node = null;
    
    @property(Node)
    lettersContainer: Node = null;
    
    @property(Label)
    letterLabelPrefab: Label = null;
    
    private wordData: WordData = null;
    private letterNodes: Node[] = [];
    private inputIndices: number[] = [];
    
    /**
     * 初始化单词显示
     */
    public init(wordData: WordData): void {
        this.wordData = wordData;
        this.clearLetters();
        this.createLetters();
        this.updateBackground();
    }
    
    /**
     * 创建字母节点
     */
    private createLetters(): void {
        const word = this.wordData.word;
        const missingIndices = this.wordData.missingIndices;
        const stressPositions = this.wordData.stressPositions || [];
        
        const letterSpacing = 30; // 字母间距
        const totalWidth = word.length * letterSpacing;
        const startX = -totalWidth / 2;
        
        for (let i = 0; i < word.length; i++) {
            const letter = word[i];
            const isMissing = missingIndices.includes(i);
            const isStress = stressPositions.includes(i);
            
            // 创建字母节点
            const letterNode = new Node(`Letter_${i}`);
            this.lettersContainer.addChild(letterNode);
            
            // 添加 Label 组件
            const label = letterNode.addComponent(Label);
            label.string = isMissing ? '_' : letter.toLowerCase();
            label.fontSize = 32;
            label.lineHeight = 32;
            
            // 设置颜色
            if (isStress && !isMissing) {
                // 重音音节 - 红色
                label.color = new Color(255, 68, 68);
            } else if (isMissing) {
                // 缺失字母 - 深灰色下划线
                label.color = new Color(100, 100, 100);
            } else {
                // 普通字母 - 白色
                label.color = Color.WHITE;
            }
            
            // 设置位置
            const x = startX + i * letterSpacing;
            letterNode.setPosition(x, 0, 0);
            
            // 保存引用
            this.letterNodes.push(letterNode);
        }
    }
    
    /**
     * 更新输入高亮
     */
    public updateInput(input: string): void {
        this.inputIndices = [];
        let inputIndex = 0;
        
        const missingIndices = this.wordData.missingIndices;
        
        for (let i = 0; i < this.wordData.word.length; i++) {
            if (missingIndices.includes(i)) {
                if (inputIndex < input.length) {
                    const letterNode = this.letterNodes[i];
                    const label = letterNode.getComponent(Label);
                    
                    // 显示输入的字母
                    label.string = input[inputIndex].toLowerCase();
                    
                    // 验证是否正确
                    const isCorrect = input[inputIndex].toUpperCase() === 
                                    this.wordData.word[i].toUpperCase();
                    
                    if (isCorrect) {
                        // 正确 - 绿色高亮，字体放大
                        label.color = new Color(0, 255, 0);
                        letterNode.setScale(1.3, 1.3, 1);
                    } else {
                        // 错误 - 红色
                        label.color = new Color(255, 0, 0);
                        letterNode.setScale(1.0, 1.0, 1);
                    }
                    
                    this.inputIndices.push(i);
                    inputIndex++;
                }
            }
        }
    }
    
    /**
     * 显示红叉标记
     */
    public showRedCross(index: number): void {
        const letterNode = this.letterNodes[index];
        if (!letterNode) return;
        
        // 创建红叉节点
        const crossNode = new Node('RedCross');
        letterNode.addChild(crossNode);
        
        // 绘制红叉（使用 Graphics 组件）
        const graphics = crossNode.addComponent(Graphics);
        graphics.lineWidth = 3;
        graphics.strokeColor = new Color(255, 0, 0);
        
        // 绘制 X 形状
        const size = 20;
        graphics.moveTo(-size / 2, -size / 2);
        graphics.lineTo(size / 2, size / 2);
        graphics.moveTo(size / 2, -size / 2);
        graphics.lineTo(-size / 2, size / 2);
        graphics.stroke();
        
        // 闪烁动画
        this.playBlinkAnimation(crossNode);
        
        // 300ms 后移除
        this.scheduleOnce(() => {
            crossNode.destroy();
        }, 0.3);
    }
    
    /**
     * 闪烁动画
     */
    private playBlinkAnimation(node: Node): void {
        const uiOpacity = node.addComponent(UIOpacity);
        
        tween(uiOpacity)
            .to(0.1, { opacity: 0 })
            .to(0.1, { opacity: 255 })
            .union()
            .repeat(3)
            .start();
    }
    
    /**
     * 更新背景大小
     */
    private updateBackground(): void {
        const sprite = this.background.getComponent(Sprite);
        const width = this.wordData.word.length * 30 + 40;
        const height = 50;
        
        this.background.setContentSize(width, height);
        sprite.color = new Color(0, 0, 0, 77); // 半透明黑色
    }
    
    /**
     * 下降动画
     */
    public fall(deltaTime: number): void {
        const fallSpeed = GameConfig.BASE_FALL_SPEED + 
                         (this.gameLevel - 1) * GameConfig.SPEED_INCREMENT;
        
        const pos = this.node.position;
        this.node.setPosition(pos.x, pos.y - fallSpeed, pos.z);
    }
    
    /**
     * 销毁动画
     */
    public playDestroyAnimation(callback: () => void): void {
        tween(this.node)
            .to(0.3, { scale: new Vec3(0, 0, 0) })
            .call(callback)
            .start();
    }
    
    /**
     * 清理字母节点
     */
    private clearLetters(): void {
        for (const node of this.letterNodes) {
            node.destroy();
        }
        this.letterNodes = [];
    }
}
```

---

## 3️⃣ 炮管系统完整实现

### 3.1 炮管结构

根据设计文档，炮管系统包含 5 层结构：

```
Cannon (根节点)
├── Base (基座 - 不旋转)
├── RotateGroup (旋转组 - 跟随瞄准旋转)
│   ├── Platform (炮台平台)
│   ├── Barrel (炮管主体)
│   │   ├── BarrelBack (后段)
│   │   ├── BarrelMiddle (中段)
│   │   ├── BarrelFront (前段)
│   │   └── Muzzle (炮口)
│   └── Fuse (燃烧引信)
│       ├── FuseLine (引信绳子)
│       └── FuseParticles (火焰粒子)
```

### 3.2 CannonSystem 实现

```typescript
// assets/scripts/systems/CannonSystem.ts
import { _decorator, Component, Node, Vec3, Quat, tween, math, ParticleSystem2D } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('CannonSystem')
export class CannonSystem extends Component {
    // ========== 节点引用 ==========
    
    @property(Node)
    base: Node = null; // 基座（不旋转）
    
    @property(Node)
    rotateGroup: Node = null; // 旋转组
    
    @property(Node)
    platform: Node = null; // 炮台平台
    
    @property(Node)
    barrel: Node = null; // 炮管主体
    
    @property(Node)
    barrelBack: Node = null; // 炮管后段
    
    @property(Node)
    barrelMiddle: Node = null; // 炮管中段
    
    @property(Node)
    barrelFront: Node = null; // 炮管前段
    
    @property(Node)
    muzzle: Node = null; // 炮口
    
    @property(Node)
    fuse: Node = null; // 引信
    
    @property(ParticleSystem2D)
    fuseParticles: ParticleSystem2D = null; // 火焰粒子
    
    @property(Prefab)
    bulletPrefab: Prefab = null; // 炮弹预制体
    
    // ========== 炮管状态 ==========
    
    private targetAngle: number = 0; // 目标角度
    private currentAngle: number = 0; // 当前角度
    private recoil: number = 0; // 后坐力
    
    // 引信摆动
    private fuseAngle: number = 0; // 引信角度
    private fuseAngularVelocity: number = 0; // 引信角速度
    
    // 配置
    private readonly AIM_SPEED = 0.2; // 瞄准速度（插值）
    private readonly RECOIL_DISTANCE = 20; // 后坐距离
    private readonly RECOIL_DECAY = 0.88; // 后坐衰减
    private readonly MUZZLE_LENGTH = 118; // 炮口距离
    
    /**
     * 初始化
     */
    public initialize(): void {
        this.setupCannonVisuals();
        this.setupFuse();
    }
    
    /**
     * 设置炮管视觉效果
     */
    private setupCannonVisuals(): void {
        // 基座 - 半圆形石质效果
        this.createBase();
        
        // 炮台平台 - 金属圆柱
        this.createPlatform();
        
        // 炮管 - 三段式金属渐变
        this.createBarrel();
        
        // 炮口 - 蓝色装饰
        this.createMuzzle();
    }
    
    /**
     * 创建基座（使用 Graphics 绘制）
     */
    private createBase(): void {
        const graphics = this.base.addComponent(Graphics);
        
        // 半圆形
        const radius = 60;
        graphics.fillColor = new Color(139, 141, 143); // 石灰色
        graphics.arc(0, 0, radius, Math.PI, 0, false);
        graphics.fill();
        
        // 添加纹理（石块斑点）
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI;
            const distance = Math.random() * radius;
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance;
            const size = 10 + Math.random() * 8;
            
            graphics.fillColor = new Color(93, 109, 126); // 深灰色
            graphics.circle(x, y, size);
            graphics.fill();
        }
        
        // 轮廓线
        graphics.lineWidth = 3;
        graphics.strokeColor = new Color(44, 62, 80);
        graphics.arc(0, 0, radius, Math.PI, 0, false);
        graphics.stroke();
    }
    
    /**
     * 创建炮台平台
     */
    private createPlatform(): void {
        const sprite = this.platform.addComponent(Sprite);
        // 设置圆柱形纹理
        // TODO: 创建或加载纹理资源
    }
    
    /**
     * 创建炮管（三段式）
     */
    private createBarrel(): void {
        // 后段
        this.createBarrelSegment(this.barrelBack, 30, 30, -50, -20);
        
        // 中段
        this.createBarrelSegment(this.barrelMiddle, 26, 30, -75, -45);
        
        // 前段
        this.createBarrelSegment(this.barrelFront, 22, 35, -105, -70);
    }
    
    /**
     * 创建炮管段
     */
    private createBarrelSegment(node: Node, width: number, length: number, 
                                startY: number, endY: number): void {
        const graphics = node.addComponent(Graphics);
        
        // 金属渐变
        graphics.fillColor = new Color(74, 95, 127);
        graphics.rect(-width / 2, startY, width, length);
        graphics.fill();
        
        // 左侧高光
        graphics.fillColor = new Color(255, 255, 255, 64);
        graphics.rect(-width / 2, startY, 6, length);
        graphics.fill();
        
        // 右侧阴影
        graphics.fillColor = new Color(0, 0, 0, 77);
        graphics.rect(width / 2 - 5, startY, 5, length);
        graphics.fill();
        
        // 装饰环（铆钉）
        this.addRivets(graphics, width, startY, length);
    }
    
    /**
     * 添加铆钉
     */
    private addRivets(graphics: Graphics, width: number, startY: number, length: number): void {
        const rivetPositions = [0.2, 0.5, 0.8];
        
        for (const ratio of rivetPositions) {
            const y = startY + length * ratio;
            
            // 左侧铆钉
            graphics.fillColor = new Color(44, 62, 80);
            graphics.circle(-width / 2 + 3, y, 3);
            graphics.fill();
            
            // 高光
            graphics.fillColor = new Color(255, 255, 255, 128);
            graphics.circle(-width / 2 + 2, y - 1, 1);
            graphics.fill();
            
            // 右侧铆钉
            graphics.fillColor = new Color(44, 62, 80);
            graphics.circle(width / 2 - 3, y, 3);
            graphics.fill();
        }
    }
    
    /**
     * 创建炮口
     */
    private createMuzzle(): void {
        const graphics = this.muzzle.addComponent(Graphics);
        
        // 粗圆柱体
        const width = 36;
        const length = 13;
        
        // 主体
        graphics.fillColor = new Color(74, 95, 127);
        graphics.rect(-width / 2, -118, width, length);
        graphics.fill();
        
        // 蓝色装饰
        graphics.strokeColor = new Color(52, 152, 219);
        graphics.lineWidth = 2;
        graphics.rect(-width / 2, -118, width, length);
        graphics.stroke();
        
        // 前端面蓝色渐变
        graphics.fillColor = new Color(93, 173, 226);
        graphics.circle(0, -118, width / 2);
        graphics.fill();
    }
    
    /**
     * 设置引信
     */
    private setupFuse(): void {
        // 引信绳子
        const graphics = this.fuse.addComponent(Graphics);
        graphics.lineWidth = 2;
        graphics.strokeColor = new Color(62, 39, 35); // 深棕色
        graphics.lineCap = Graphics.LineCap.ROUND;
        
        // 初始位置（垂直向下）
        this.fuseAngle = Math.PI / 2;
        
        // 启动粒子系统
        this.fuseParticles.resetSystem();
    }
    
    /**
     * 每帧更新
     */
    public update(deltaTime: number): void {
        // 更新瞄准
        this.updateAiming(deltaTime);
        
        // 更新后坐力
        this.updateRecoil(deltaTime);
        
        // 更新引信摆动
        this.updateFuse(deltaTime);
        
        // 渲染炮管
        this.renderCannon();
    }
    
    /**
     * 瞄准目标
     */
    public aimAt(targetPos: Vec3): void {
        // 计算目标角度
        const cannonPos = this.node.getWorldPosition();
        const dx = targetPos.x - cannonPos.x;
        const dy = targetPos.y - cannonPos.y;
        
        this.targetAngle = Math.atan2(dx, dy);
    }
    
    /**
     * 更新瞄准（平滑插值）
     */
    private updateAiming(deltaTime: number): void {
        // 角度插值
        const angleDiff = this.targetAngle - this.currentAngle;
        this.currentAngle += angleDiff * this.AIM_SPEED;
        
        // 限制角度范围（-45° 到 45°）
        const maxAngle = math.toRadian(45);
        this.currentAngle = math.clamp(this.currentAngle, -maxAngle, maxAngle);
        
        // 应用旋转到旋转组
        const euler = new Vec3(0, 0, -math.toDegree(this.currentAngle));
        this.rotateGroup.setRotationFromEuler(euler);
    }
    
    /**
     * 发射炮弹
     */
    public fire(targetPos: Vec3): void {
        // 触发后坐力
        this.recoil = this.RECOIL_DISTANCE;
        
        // 创建炮弹
        const bullet = instantiate(this.bulletPrefab);
        
        // 计算炮口位置
        const muzzlePos = this.calculateMuzzlePosition();
        bullet.setPosition(muzzlePos);
        
        // 炮弹飞向目标
        const bulletEntity = bullet.getComponent(BulletEntity);
        bulletEntity.flyTo(targetPos);
        
        // 添加到场景
        this.node.parent.addChild(bullet);
    }
    
    /**
     * 计算炮口位置
     */
    private calculateMuzzlePosition(): Vec3 {
        const cannonPos = this.node.getWorldPosition();
        const x = cannonPos.x + Math.sin(this.currentAngle) * this.MUZZLE_LENGTH;
        const y = cannonPos.y + Math.cos(this.currentAngle) * this.MUZZLE_LENGTH;
        
        return new Vec3(x, y, 0);
    }
    
    /**
     * 更新后坐力
     */
    private updateRecoil(deltaTime: number): void {
        if (this.recoil > 0.1) {
            this.recoil *= this.RECOIL_DECAY;
            
            // 应用后坐到旋转组（沿炮管方向后退）
            const offsetX = -Math.sin(this.currentAngle) * this.recoil;
            const offsetY = -Math.cos(this.currentAngle) * this.recoil;
            
            this.rotateGroup.setPosition(offsetX, offsetY, 0);
        } else {
            this.recoil = 0;
            this.rotateGroup.setPosition(0, 0, 0);
        }
    }
    
    /**
     * 更新引信摆动（物理模拟）
     */
    private updateFuse(deltaTime: number): void {
        const gravity = 0.3; // 重力影响
        const damping = 0.95; // 阻尼系数
        
        // 世界下方向（90° = π/2）
        const worldDown = Math.PI / 2;
        
        // 相对于炮管的目标角度
        const targetAngle = worldDown - this.currentAngle;
        
        // 角加速度（恢复力）
        const angularAcceleration = Math.sin(targetAngle - this.fuseAngle) * gravity;
        
        // 更新角速度
        this.fuseAngularVelocity += angularAcceleration;
        this.fuseAngularVelocity *= damping;
        
        // 更新角度
        this.fuseAngle += this.fuseAngularVelocity;
        
        // 渲染引信
        this.renderFuse();
    }
    
    /**
     * 渲染引信
     */
    private renderFuse(): void {
        const graphics = this.fuse.getComponent(Graphics);
        graphics.clear();
        
        const attachX = 18;
        const attachY = -60;
        const length = 12;
        
        // 计算末端位置
        const endX = attachX + Math.sin(this.fuseAngle) * length;
        const endY = attachY + Math.cos(this.fuseAngle) * length;
        
        // 绘制引信绳子
        graphics.lineWidth = 2;
        graphics.strokeColor = new Color(62, 39, 35);
        graphics.moveTo(attachX, attachY);
        graphics.lineTo(endX, endY);
        graphics.stroke();
        
        // 更新粒子位置
        this.fuseParticles.node.setPosition(endX, endY, 0);
        
        // 设置粒子方向（沿引信延伸方向）
        const particleAngle = this.fuseAngle;
        // TODO: 设置粒子系统的方向
    }
    
    /**
     * 渲染炮管（更新视觉效果）
     */
    private renderCannon(): void {
        // 基座始终水平（不受旋转影响）
        this.base.setRotationFromEuler(0, 0, 0);
        
        // 其他部件跟随旋转组
    }
}
```

---

## 4️⃣ 粒子系统实现

### 4.1 爆炸粒子系统

```typescript
// assets/scripts/systems/ExplosionSystem.ts
import { _decorator, Component, Node, Prefab, instantiate, Vec3, 
         ParticleSystem2D, Label, tween, Color } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('ExplosionSystem')
export class ExplosionSystem extends Component {
    @property(Prefab)
    explosionPrefab: Prefab = null;
    
    @property(Node)
    explosionsContainer: Node = null;
    
    @property(Prefab)
    meaningLabelPrefab: Prefab = null;
    
    /**
     * 初始化
     */
    public initialize(): void {
        if (!this.explosionsContainer) {
            this.explosionsContainer = new Node('ExplosionsContainer');
            this.node.addChild(this.explosionsContainer);
        }
    }
    
    /**
     * 创建爆炸效果
     */
    public createExplosion(position: Vec3, meaning: string): void {
        // 1. 创建粒子爆炸
        this.createParticleExplosion(position);
        
        // 2. 创建中文翻译爆炸动画
        this.createMeaningExplosion(position, meaning);
    }
    
    /**
     * 创建粒子爆炸
     */
    private createParticleExplosion(position: Vec3): void {
        const explosion = instantiate(this.explosionPrefab);
        this.explosionsContainer.addChild(explosion);
        explosion.setWorldPosition(position);
        
        // 获取粒子系统组件
        const particleSystem = explosion.getComponent(ParticleSystem2D);
        
        // 配置粒子参数
        particleSystem.duration = 0.5; // 持续时间
        particleSystem.life = 1.0; // 粒子生命
        particleSystem.lifeVar = 0.3; // 生命变化
        particleSystem.startSize = 8; // 起始大小
        particleSystem.startSizeVar = 4; // 大小变化
        particleSystem.endSize = 0; // 结束大小
        particleSystem.angle = 90; // 发射角度
        particleSystem.angleVar = 360; // 角度变化（全方向）
        particleSystem.speed = 200; // 速度
        particleSystem.speedVar = 50; // 速度变化
        particleSystem.gravity = new Vec3(0, -100, 0); // 重力
        
        // 多彩颜色（6种颜色）
        const colors = [
            new Color(255, 0, 0),     // 红色
            new Color(255, 165, 0),   // 橙色
            new Color(255, 255, 0),   // 黄色
            new Color(0, 255, 0),     // 绿色
            new Color(0, 0, 255),     // 蓝色
            new Color(238, 130, 238)  // 紫色
        ];
        
        // 随机选择颜色
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        particleSystem.startColor = randomColor;
        particleSystem.endColor = new Color(randomColor.r, randomColor.g, randomColor.b, 0);
        
        // 启动粒子系统
        particleSystem.resetSystem();
        
        // 1.5秒后销毁
        this.scheduleOnce(() => {
            explosion.destroy();
        }, 1.5);
    }
    
    /**
     * 创建中文翻译爆炸动画
     */
    private createMeaningExplosion(position: Vec3, meaning: string): void {
        const meaningNode = instantiate(this.meaningLabelPrefab);
        this.explosionsContainer.addChild(meaningNode);
        meaningNode.setWorldPosition(position);
        
        // 获取 Label 组件
        const label = meaningNode.getComponent(Label);
        label.string = meaning;
        label.fontSize = 48; // 初始字体大小
        label.color = new Color(255, 215, 0); // 金黄色
        
        // 设置描边
        label.enableOutline = true;
        label.outlineWidth = 2;
        label.outlineColor = new Color(0, 0, 0);
        
        // 动画序列：放大 → 显示 → 淡出
        tween(meaningNode)
            // 从 0.5 倍快速放大到 2.5 倍
            .set({ scale: new Vec3(0.5, 0.5, 1) })
            .to(0.3, { scale: new Vec3(2.5, 2.5, 1) }, { easing: 'backOut' })
            // 保持显示 1 秒
            .delay(1.0)
            // 淡出
            .to(0.5, { 
                scale: new Vec3(3.0, 3.0, 1),
                position: new Vec3(position.x, position.y + 50, 0)
            })
            .call(() => {
                // 销毁节点
                meaningNode.destroy();
            })
            .start();
        
        // 透明度动画
        const uiOpacity = meaningNode.addComponent(UIOpacity);
        tween(uiOpacity)
            .delay(1.3)
            .to(0.5, { opacity: 0 })
            .start();
    }
    
    /**
     * 每帧更新
     */
    public update(deltaTime: number): void {
        // 粒子系统自动更新，无需手动处理
    }
    
    /**
     * 清理
     */
    public cleanup(): void {
        this.explosionsContainer.removeAllChildren();
    }
}
```

### 4.2 炮弹实体

```typescript
// assets/scripts/entities/BulletEntity.ts
import { _decorator, Component, Node, Vec3, Sprite, Color, Graphics,
         tween, ParticleSystem2D } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('BulletEntity')
export class BulletEntity extends Component {
    @property(Sprite)
    outerGlow: Sprite = null; // 外层光晕
    
    @property(Sprite)
    middleFire: Sprite = null; // 中层火球
    
    @property(Sprite)
    innerCore: Sprite = null; // 内核
    
    @property(ParticleSystem2D)
    flameParticles: ParticleSystem2D = null; // 火焰粒子
    
    @property(Node)
    trail: Node = null; // 火焰尾迹
    
    private velocity: Vec3 = new Vec3();
    private rotationSpeed: number = 0.3; // 旋转速度
    private trailPoints: Vec3[] = [];
    private readonly MAX_TRAIL_POINTS = 20;
    private readonly SPEED = 15; // 像素/帧
    
    /**
     * 初始化火球视觉
     */
    protected onLoad(): void {
        this.setupVisuals();
        this.setupTrail();
    }
    
    /**
     * 设置视觉效果
     */
    private setupVisuals(): void {
        // 外层光晕（红色）
        this.outerGlow.color = new Color(255, 100, 0);
        this.outerGlow.node.setScale(2.0, 2.0, 1);
        
        // 中层火球（橙色）
        this.middleFire.color = new Color(255, 200, 0);
        this.middleFire.node.setScale(1.25, 1.25, 1);
        
        // 内核（亮黄色）
        this.innerCore.color = new Color(255, 255, 200);
        this.innerCore.node.setScale(0.625, 0.625, 1);
        
        // 启动火焰粒子
        this.flameParticles.resetSystem();
    }
    
    /**
     * 设置尾迹
     */
    private setupTrail(): void {
        // 初始化尾迹点
        for (let i = 0; i < this.MAX_TRAIL_POINTS; i++) {
            this.trailPoints.push(new Vec3());
        }
    }
    
    /**
     * 飞向目标
     */
    public flyTo(targetPos: Vec3): void {
        const currentPos = this.node.getWorldPosition();
        const direction = new Vec3();
        Vec3.subtract(direction, targetPos, currentPos);
        direction.normalize();
        
        this.velocity = direction.multiplyScalar(this.SPEED);
    }
    
    /**
     * 每帧更新
     */
    protected update(deltaTime: number): void {
        // 移动
        const pos = this.node.position;
        pos.add(this.velocity.multiplyScalar(deltaTime * 60));
        this.node.setPosition(pos);
        
        // 旋转（火焰纹理）
        const currentRotation = this.node.eulerAngles;
        this.node.setRotationFromEuler(
            currentRotation.x,
            currentRotation.y,
            currentRotation.z + this.rotationSpeed
        );
        
        // 更新尾迹
        this.updateTrail();
    }
    
    /**
     * 更新尾迹
     */
    private updateTrail(): void {
        const currentPos = this.node.getWorldPosition();
        
        // 移动所有点
        for (let i = this.trailPoints.length - 1; i > 0; i--) {
            this.trailPoints[i].set(this.trailPoints[i - 1]);
        }
        
        // 添加新点
        this.trailPoints[0].set(currentPos);
        
        // 绘制尾迹
        this.drawTrail();
    }
    
    /**
     * 绘制尾迹
     */
    private drawTrail(): void {
        const graphics = this.trail.getComponent(Graphics);
        if (!graphics) return;
        
        graphics.clear();
        
        // 绘制渐变尾迹
        for (let i = 0; i < this.trailPoints.length - 1; i++) {
            const alpha = (this.trailPoints.length - i) / this.trailPoints.length;
            const size = 12 * alpha;
            
            // 渐变颜色（橙黄 → 橙红）
            const r = 255;
            const g = 200 - (i / this.trailPoints.length) * 100;
            const b = 0;
            
            graphics.fillColor = new Color(r, g, b, alpha * 255);
            graphics.circle(
                this.trailPoints[i].x,
                this.trailPoints[i].y,
                size
            );
            graphics.fill();
        }
    }
    
    /**
     * 检查碰撞
     */
    public checkCollision(targetPos: Vec3): boolean {
        const currentPos = this.node.getWorldPosition();
        const distance = Vec3.distance(currentPos, targetPos);
        
        return distance < 20; // 碰撞距离
    }
    
    /**
     * 销毁
     */
    public destroy(): void {
        this.node.destroy();
    }
}
```

---

## 5️⃣ 动画系统实现

### 5.1 使用 Tween 动画

```typescript
// 常用动画示例

// 1. 位置动画
tween(node)
    .to(1, { position: new Vec3(100, 100, 0) })
    .start();

// 2. 缩放动画
tween(node)
    .to(0.5, { scale: new Vec3(1.5, 1.5, 1) })
    .start();

// 3. 旋转动画
tween(node)
    .to(1, { eulerAngles: new Vec3(0, 0, 360) })
    .start();

// 4. 透明度动画
const uiOpacity = node.addComponent(UIOpacity);
tween(uiOpacity)
    .to(0.5, { opacity: 0 })
    .start();

// 5. 链式动画
tween(node)
    .to(0.5, { position: new Vec3(100, 0, 0) })
    .delay(0.5)
    .to(0.5, { scale: new Vec3(2, 2, 1) })
    .call(() => {
        console.log('动画完成');
    })
    .start();

// 6. 循环动画
tween(node)
    .to(1, { position: new Vec3(100, 0, 0) })
    .to(1, { position: new Vec3(0, 0, 0) })
    .union()
    .repeatForever()
    .start();

// 7. 缓动函数
tween(node)
    .to(1, { position: new Vec3(100, 0, 0) }, { easing: 'backOut' })
    .start();

// 常用缓动函数：
// - linear
// - sineIn, sineOut, sineInOut
// - backIn, backOut, backInOut
// - bounceIn, bounceOut, bounceInOut
// - elasticIn, elasticOut, elasticInOut
```

---

## 6️⃣ 性能优化建议

### 6.1 批处理

```typescript
// 合并相同材质的 Sprite
// 在编辑器中设置 Sprite 的 Atlas 属性
```

### 6.2 对象池

```typescript
// 使用对象池管理频繁创建/销毁的对象
private bulletPool: NodePool = new NodePool();

getBullet(): Node {
    return this.bulletPool.size() > 0 
        ? this.bulletPool.get() 
        : instantiate(this.bulletPrefab);
}

recycleBullet(bullet: Node): void {
    this.bulletPool.put(bullet);
}
```

### 6.3 减少 Draw Call

- 使用图集（Atlas）合并纹理
- 减少节点层级
- 合并静态节点
- 使用批处理

---

## 7️⃣ 调试工具

### 开启性能统计

```typescript
// 在 start() 中
director.getScheduler().enableForTarget(this);
game.frameRate = 60;

// 显示 FPS
if (DEBUG) {
    profiler.showStats();
}
```

---

## 验证清单

- [ ] 单词节点正确显示
- [ ] 炮管五层结构完整
- [ ] 炮管瞄准流畅
- [ ] 后坐力效果明显
- [ ] 引信物理摆动自然
- [ ] 火球三层结构正确
- [ ] 火焰尾迹流畅
- [ ] 粒子爆炸多彩
- [ ] 中文翻译爆炸动画完整
- [ ] 动画流畅（60 FPS）

---

**渲染系统改造完成！** ✅

下一步：阅读 [07_UI系统重建.md](./07_UI系统重建.md)




