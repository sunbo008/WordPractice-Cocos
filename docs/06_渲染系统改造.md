# æ¸²æŸ“ç³»ç»Ÿæ”¹é€ 

## ğŸ“‹ æœ¬æ–‡æ¡£å†…å®¹

- Canvas 2D åˆ° Cocos èŠ‚ç‚¹ç³»ç»Ÿè½¬æ¢
- ç‚®ç®¡ç³»ç»Ÿå®Œæ•´å®ç°
- ç²’å­æ•ˆæœç³»ç»Ÿ
- åŠ¨ç”»ç³»ç»Ÿå®ç°

---

## 1ï¸âƒ£ æ¸²æŸ“ç³»ç»Ÿå¯¹æ¯”

### 1.1 Canvas 2D vs Cocos èŠ‚ç‚¹ç³»ç»Ÿ

| ç‰¹æ€§ | Canvas 2D | Cocos Creator |
|------|-----------|---------------|
| **ç»˜åˆ¶æ–¹å¼** | æ‰‹åŠ¨è°ƒç”¨ç»˜åˆ¶ API | è‡ªåŠ¨æ¸²æŸ“èŠ‚ç‚¹æ ‘ |
| **åæ ‡ç³»ç»Ÿ** | å·¦ä¸Šè§’åŸç‚¹ï¼ŒYå‘ä¸‹ | å¯é…ç½®é”šç‚¹ï¼ŒYå‘ä¸Š |
| **å›¾å±‚ç®¡ç†** | æ‰‹åŠ¨æ§åˆ¶ç»˜åˆ¶é¡ºåº | z-index è‡ªåŠ¨æ’åº |
| **æ€§èƒ½ä¼˜åŒ–** | æ‰‹åŠ¨è„çŸ©å½¢æ£€æµ‹ | å¼•æ“è‡ªåŠ¨æ‰¹å¤„ç† |
| **æ—‹è½¬ç¼©æ”¾** | æ‰‹åŠ¨çŸ©é˜µå˜æ¢ | `node.angle/scale` |
| **é€æ˜åº¦** | `globalAlpha` | `node.opacity` |
| **é¢œè‰²æ··åˆ** | `globalCompositeOperation` | æè´¨ç³»ç»Ÿ |

### 1.2 Canvas ç»˜åˆ¶ä»£ç ç¤ºä¾‹ï¼ˆåŸç‰ˆï¼‰

```javascript
// proj/src/systems/GameRenderer.js
drawCannon() {
    const ctx = this.ctx;
    
    ctx.save();
    ctx.translate(this.cannonX, this.cannonY);
    ctx.rotate(this.cannonAngle);
    
    // ç»˜åˆ¶ç‚®ç®¡
    ctx.fillStyle = '#4A5F7F';
    ctx.fillRect(-10, -50, 20, 50);
    
    // ç»˜åˆ¶ç‚®å£
    ctx.fillStyle = '#3498DB';
    ctx.beginPath();
    ctx.arc(0, -50, 15, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
}

drawWord(word) {
    const ctx = this.ctx;
    
    // ç»˜åˆ¶èƒŒæ™¯
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(word.x - 50, word.y - 20, 100, 40);
    
    // ç»˜åˆ¶æ–‡å­—
    ctx.fillStyle = 'white';
    ctx.font = '32px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(word.text, word.x, word.y);
}

drawParticles() {
    for (const particle of this.particles) {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = particle.alpha;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1.0;
}
```

---

## 2ï¸âƒ£ Cocos èŠ‚ç‚¹ç³»ç»Ÿå®ç°

### 2.1 å•è¯å®ä½“æ¸²æŸ“

```typescript
// assets/scripts/entities/WordEntity.ts
import { _decorator, Component, Node, Label, Sprite, Color, UIOpacity } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('WordEntity')
export class WordEntity extends Component {
    @property(Node)
    background: Node = null;
    
    @property(Node)
    lettersContainer: Node = null;
    
    @property(Label)
    letterLabelPrefab: Label = null;
    
    private wordData: WordData = null;
    private letterNodes: Node[] = [];
    private inputIndices: number[] = [];
    
    /**
     * åˆå§‹åŒ–å•è¯æ˜¾ç¤º
     */
    public init(wordData: WordData): void {
        this.wordData = wordData;
        this.clearLetters();
        this.createLetters();
        this.updateBackground();
    }
    
    /**
     * åˆ›å»ºå­—æ¯èŠ‚ç‚¹
     */
    private createLetters(): void {
        const word = this.wordData.word;
        const missingIndices = this.wordData.missingIndices;
        const stressPositions = this.wordData.stressPositions || [];
        
        const letterSpacing = 30; // å­—æ¯é—´è·
        const totalWidth = word.length * letterSpacing;
        const startX = -totalWidth / 2;
        
        for (let i = 0; i < word.length; i++) {
            const letter = word[i];
            const isMissing = missingIndices.includes(i);
            const isStress = stressPositions.includes(i);
            
            // åˆ›å»ºå­—æ¯èŠ‚ç‚¹
            const letterNode = new Node(`Letter_${i}`);
            this.lettersContainer.addChild(letterNode);
            
            // æ·»åŠ  Label ç»„ä»¶
            const label = letterNode.addComponent(Label);
            label.string = isMissing ? '_' : letter.toLowerCase();
            label.fontSize = 32;
            label.lineHeight = 32;
            
            // è®¾ç½®é¢œè‰²
            if (isStress && !isMissing) {
                // é‡éŸ³éŸ³èŠ‚ - çº¢è‰²
                label.color = new Color(255, 68, 68);
            } else if (isMissing) {
                // ç¼ºå¤±å­—æ¯ - æ·±ç°è‰²ä¸‹åˆ’çº¿
                label.color = new Color(100, 100, 100);
            } else {
                // æ™®é€šå­—æ¯ - ç™½è‰²
                label.color = Color.WHITE;
            }
            
            // è®¾ç½®ä½ç½®
            const x = startX + i * letterSpacing;
            letterNode.setPosition(x, 0, 0);
            
            // ä¿å­˜å¼•ç”¨
            this.letterNodes.push(letterNode);
        }
    }
    
    /**
     * æ›´æ–°è¾“å…¥é«˜äº®
     */
    public updateInput(input: string): void {
        this.inputIndices = [];
        let inputIndex = 0;
        
        const missingIndices = this.wordData.missingIndices;
        
        for (let i = 0; i < this.wordData.word.length; i++) {
            if (missingIndices.includes(i)) {
                if (inputIndex < input.length) {
                    const letterNode = this.letterNodes[i];
                    const label = letterNode.getComponent(Label);
                    
                    // æ˜¾ç¤ºè¾“å…¥çš„å­—æ¯
                    label.string = input[inputIndex].toLowerCase();
                    
                    // éªŒè¯æ˜¯å¦æ­£ç¡®
                    const isCorrect = input[inputIndex].toUpperCase() === 
                                    this.wordData.word[i].toUpperCase();
                    
                    if (isCorrect) {
                        // æ­£ç¡® - ç»¿è‰²é«˜äº®ï¼Œå­—ä½“æ”¾å¤§
                        label.color = new Color(0, 255, 0);
                        letterNode.setScale(1.3, 1.3, 1);
                    } else {
                        // é”™è¯¯ - çº¢è‰²
                        label.color = new Color(255, 0, 0);
                        letterNode.setScale(1.0, 1.0, 1);
                    }
                    
                    this.inputIndices.push(i);
                    inputIndex++;
                }
            }
        }
    }
    
    /**
     * æ˜¾ç¤ºçº¢å‰æ ‡è®°
     */
    public showRedCross(index: number): void {
        const letterNode = this.letterNodes[index];
        if (!letterNode) return;
        
        // åˆ›å»ºçº¢å‰èŠ‚ç‚¹
        const crossNode = new Node('RedCross');
        letterNode.addChild(crossNode);
        
        // ç»˜åˆ¶çº¢å‰ï¼ˆä½¿ç”¨ Graphics ç»„ä»¶ï¼‰
        const graphics = crossNode.addComponent(Graphics);
        graphics.lineWidth = 3;
        graphics.strokeColor = new Color(255, 0, 0);
        
        // ç»˜åˆ¶ X å½¢çŠ¶
        const size = 20;
        graphics.moveTo(-size / 2, -size / 2);
        graphics.lineTo(size / 2, size / 2);
        graphics.moveTo(size / 2, -size / 2);
        graphics.lineTo(-size / 2, size / 2);
        graphics.stroke();
        
        // é—ªçƒåŠ¨ç”»
        this.playBlinkAnimation(crossNode);
        
        // 300ms åç§»é™¤
        this.scheduleOnce(() => {
            crossNode.destroy();
        }, 0.3);
    }
    
    /**
     * é—ªçƒåŠ¨ç”»
     */
    private playBlinkAnimation(node: Node): void {
        const uiOpacity = node.addComponent(UIOpacity);
        
        tween(uiOpacity)
            .to(0.1, { opacity: 0 })
            .to(0.1, { opacity: 255 })
            .union()
            .repeat(3)
            .start();
    }
    
    /**
     * æ›´æ–°èƒŒæ™¯å¤§å°
     */
    private updateBackground(): void {
        const sprite = this.background.getComponent(Sprite);
        const width = this.wordData.word.length * 30 + 40;
        const height = 50;
        
        this.background.setContentSize(width, height);
        sprite.color = new Color(0, 0, 0, 77); // åŠé€æ˜é»‘è‰²
    }
    
    /**
     * ä¸‹é™åŠ¨ç”»
     */
    public fall(deltaTime: number): void {
        const fallSpeed = GameConfig.BASE_FALL_SPEED + 
                         (this.gameLevel - 1) * GameConfig.SPEED_INCREMENT;
        
        const pos = this.node.position;
        this.node.setPosition(pos.x, pos.y - fallSpeed, pos.z);
    }
    
    /**
     * é”€æ¯åŠ¨ç”»
     */
    public playDestroyAnimation(callback: () => void): void {
        tween(this.node)
            .to(0.3, { scale: new Vec3(0, 0, 0) })
            .call(callback)
            .start();
    }
    
    /**
     * æ¸…ç†å­—æ¯èŠ‚ç‚¹
     */
    private clearLetters(): void {
        for (const node of this.letterNodes) {
            node.destroy();
        }
        this.letterNodes = [];
    }
}
```

---

## 3ï¸âƒ£ ç‚®ç®¡ç³»ç»Ÿå®Œæ•´å®ç°

### 3.1 ç‚®ç®¡ç»“æ„

æ ¹æ®è®¾è®¡æ–‡æ¡£ï¼Œç‚®ç®¡ç³»ç»ŸåŒ…å« 5 å±‚ç»“æ„ï¼š

```
Cannon (æ ¹èŠ‚ç‚¹)
â”œâ”€â”€ Base (åŸºåº§ - ä¸æ—‹è½¬)
â”œâ”€â”€ RotateGroup (æ—‹è½¬ç»„ - è·Ÿéšç„å‡†æ—‹è½¬)
â”‚   â”œâ”€â”€ Platform (ç‚®å°å¹³å°)
â”‚   â”œâ”€â”€ Barrel (ç‚®ç®¡ä¸»ä½“)
â”‚   â”‚   â”œâ”€â”€ BarrelBack (åæ®µ)
â”‚   â”‚   â”œâ”€â”€ BarrelMiddle (ä¸­æ®µ)
â”‚   â”‚   â”œâ”€â”€ BarrelFront (å‰æ®µ)
â”‚   â”‚   â””â”€â”€ Muzzle (ç‚®å£)
â”‚   â””â”€â”€ Fuse (ç‡ƒçƒ§å¼•ä¿¡)
â”‚       â”œâ”€â”€ FuseLine (å¼•ä¿¡ç»³å­)
â”‚       â””â”€â”€ FuseParticles (ç«ç„°ç²’å­)
```

### 3.2 CannonSystem å®ç°

```typescript
// assets/scripts/systems/CannonSystem.ts
import { _decorator, Component, Node, Vec3, Quat, tween, math, ParticleSystem2D } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('CannonSystem')
export class CannonSystem extends Component {
    // ========== èŠ‚ç‚¹å¼•ç”¨ ==========
    
    @property(Node)
    base: Node = null; // åŸºåº§ï¼ˆä¸æ—‹è½¬ï¼‰
    
    @property(Node)
    rotateGroup: Node = null; // æ—‹è½¬ç»„
    
    @property(Node)
    platform: Node = null; // ç‚®å°å¹³å°
    
    @property(Node)
    barrel: Node = null; // ç‚®ç®¡ä¸»ä½“
    
    @property(Node)
    barrelBack: Node = null; // ç‚®ç®¡åæ®µ
    
    @property(Node)
    barrelMiddle: Node = null; // ç‚®ç®¡ä¸­æ®µ
    
    @property(Node)
    barrelFront: Node = null; // ç‚®ç®¡å‰æ®µ
    
    @property(Node)
    muzzle: Node = null; // ç‚®å£
    
    @property(Node)
    fuse: Node = null; // å¼•ä¿¡
    
    @property(ParticleSystem2D)
    fuseParticles: ParticleSystem2D = null; // ç«ç„°ç²’å­
    
    @property(Prefab)
    bulletPrefab: Prefab = null; // ç‚®å¼¹é¢„åˆ¶ä½“
    
    // ========== ç‚®ç®¡çŠ¶æ€ ==========
    
    private targetAngle: number = 0; // ç›®æ ‡è§’åº¦
    private currentAngle: number = 0; // å½“å‰è§’åº¦
    private recoil: number = 0; // åååŠ›
    
    // å¼•ä¿¡æ‘†åŠ¨
    private fuseAngle: number = 0; // å¼•ä¿¡è§’åº¦
    private fuseAngularVelocity: number = 0; // å¼•ä¿¡è§’é€Ÿåº¦
    
    // é…ç½®
    private readonly AIM_SPEED = 0.2; // ç„å‡†é€Ÿåº¦ï¼ˆæ’å€¼ï¼‰
    private readonly RECOIL_DISTANCE = 20; // ååè·ç¦»
    private readonly RECOIL_DECAY = 0.88; // ååè¡°å‡
    private readonly MUZZLE_LENGTH = 118; // ç‚®å£è·ç¦»
    
    /**
     * åˆå§‹åŒ–
     */
    public initialize(): void {
        this.setupCannonVisuals();
        this.setupFuse();
    }
    
    /**
     * è®¾ç½®ç‚®ç®¡è§†è§‰æ•ˆæœ
     */
    private setupCannonVisuals(): void {
        // åŸºåº§ - åŠåœ†å½¢çŸ³è´¨æ•ˆæœ
        this.createBase();
        
        // ç‚®å°å¹³å° - é‡‘å±åœ†æŸ±
        this.createPlatform();
        
        // ç‚®ç®¡ - ä¸‰æ®µå¼é‡‘å±æ¸å˜
        this.createBarrel();
        
        // ç‚®å£ - è“è‰²è£…é¥°
        this.createMuzzle();
    }
    
    /**
     * åˆ›å»ºåŸºåº§ï¼ˆä½¿ç”¨ Graphics ç»˜åˆ¶ï¼‰
     */
    private createBase(): void {
        const graphics = this.base.addComponent(Graphics);
        
        // åŠåœ†å½¢
        const radius = 60;
        graphics.fillColor = new Color(139, 141, 143); // çŸ³ç°è‰²
        graphics.arc(0, 0, radius, Math.PI, 0, false);
        graphics.fill();
        
        // æ·»åŠ çº¹ç†ï¼ˆçŸ³å—æ–‘ç‚¹ï¼‰
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI;
            const distance = Math.random() * radius;
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance;
            const size = 10 + Math.random() * 8;
            
            graphics.fillColor = new Color(93, 109, 126); // æ·±ç°è‰²
            graphics.circle(x, y, size);
            graphics.fill();
        }
        
        // è½®å»“çº¿
        graphics.lineWidth = 3;
        graphics.strokeColor = new Color(44, 62, 80);
        graphics.arc(0, 0, radius, Math.PI, 0, false);
        graphics.stroke();
    }
    
    /**
     * åˆ›å»ºç‚®å°å¹³å°
     */
    private createPlatform(): void {
        const sprite = this.platform.addComponent(Sprite);
        // è®¾ç½®åœ†æŸ±å½¢çº¹ç†
        // TODO: åˆ›å»ºæˆ–åŠ è½½çº¹ç†èµ„æº
    }
    
    /**
     * åˆ›å»ºç‚®ç®¡ï¼ˆä¸‰æ®µå¼ï¼‰
     */
    private createBarrel(): void {
        // åæ®µ
        this.createBarrelSegment(this.barrelBack, 30, 30, -50, -20);
        
        // ä¸­æ®µ
        this.createBarrelSegment(this.barrelMiddle, 26, 30, -75, -45);
        
        // å‰æ®µ
        this.createBarrelSegment(this.barrelFront, 22, 35, -105, -70);
    }
    
    /**
     * åˆ›å»ºç‚®ç®¡æ®µ
     */
    private createBarrelSegment(node: Node, width: number, length: number, 
                                startY: number, endY: number): void {
        const graphics = node.addComponent(Graphics);
        
        // é‡‘å±æ¸å˜
        graphics.fillColor = new Color(74, 95, 127);
        graphics.rect(-width / 2, startY, width, length);
        graphics.fill();
        
        // å·¦ä¾§é«˜å…‰
        graphics.fillColor = new Color(255, 255, 255, 64);
        graphics.rect(-width / 2, startY, 6, length);
        graphics.fill();
        
        // å³ä¾§é˜´å½±
        graphics.fillColor = new Color(0, 0, 0, 77);
        graphics.rect(width / 2 - 5, startY, 5, length);
        graphics.fill();
        
        // è£…é¥°ç¯ï¼ˆé“†é’‰ï¼‰
        this.addRivets(graphics, width, startY, length);
    }
    
    /**
     * æ·»åŠ é“†é’‰
     */
    private addRivets(graphics: Graphics, width: number, startY: number, length: number): void {
        const rivetPositions = [0.2, 0.5, 0.8];
        
        for (const ratio of rivetPositions) {
            const y = startY + length * ratio;
            
            // å·¦ä¾§é“†é’‰
            graphics.fillColor = new Color(44, 62, 80);
            graphics.circle(-width / 2 + 3, y, 3);
            graphics.fill();
            
            // é«˜å…‰
            graphics.fillColor = new Color(255, 255, 255, 128);
            graphics.circle(-width / 2 + 2, y - 1, 1);
            graphics.fill();
            
            // å³ä¾§é“†é’‰
            graphics.fillColor = new Color(44, 62, 80);
            graphics.circle(width / 2 - 3, y, 3);
            graphics.fill();
        }
    }
    
    /**
     * åˆ›å»ºç‚®å£
     */
    private createMuzzle(): void {
        const graphics = this.muzzle.addComponent(Graphics);
        
        // ç²—åœ†æŸ±ä½“
        const width = 36;
        const length = 13;
        
        // ä¸»ä½“
        graphics.fillColor = new Color(74, 95, 127);
        graphics.rect(-width / 2, -118, width, length);
        graphics.fill();
        
        // è“è‰²è£…é¥°
        graphics.strokeColor = new Color(52, 152, 219);
        graphics.lineWidth = 2;
        graphics.rect(-width / 2, -118, width, length);
        graphics.stroke();
        
        // å‰ç«¯é¢è“è‰²æ¸å˜
        graphics.fillColor = new Color(93, 173, 226);
        graphics.circle(0, -118, width / 2);
        graphics.fill();
    }
    
    /**
     * è®¾ç½®å¼•ä¿¡
     */
    private setupFuse(): void {
        // å¼•ä¿¡ç»³å­
        const graphics = this.fuse.addComponent(Graphics);
        graphics.lineWidth = 2;
        graphics.strokeColor = new Color(62, 39, 35); // æ·±æ£•è‰²
        graphics.lineCap = Graphics.LineCap.ROUND;
        
        // åˆå§‹ä½ç½®ï¼ˆå‚ç›´å‘ä¸‹ï¼‰
        this.fuseAngle = Math.PI / 2;
        
        // å¯åŠ¨ç²’å­ç³»ç»Ÿ
        this.fuseParticles.resetSystem();
    }
    
    /**
     * æ¯å¸§æ›´æ–°
     */
    public update(deltaTime: number): void {
        // æ›´æ–°ç„å‡†
        this.updateAiming(deltaTime);
        
        // æ›´æ–°åååŠ›
        this.updateRecoil(deltaTime);
        
        // æ›´æ–°å¼•ä¿¡æ‘†åŠ¨
        this.updateFuse(deltaTime);
        
        // æ¸²æŸ“ç‚®ç®¡
        this.renderCannon();
    }
    
    /**
     * ç„å‡†ç›®æ ‡
     */
    public aimAt(targetPos: Vec3): void {
        // è®¡ç®—ç›®æ ‡è§’åº¦
        const cannonPos = this.node.getWorldPosition();
        const dx = targetPos.x - cannonPos.x;
        const dy = targetPos.y - cannonPos.y;
        
        this.targetAngle = Math.atan2(dx, dy);
    }
    
    /**
     * æ›´æ–°ç„å‡†ï¼ˆå¹³æ»‘æ’å€¼ï¼‰
     */
    private updateAiming(deltaTime: number): void {
        // è§’åº¦æ’å€¼
        const angleDiff = this.targetAngle - this.currentAngle;
        this.currentAngle += angleDiff * this.AIM_SPEED;
        
        // é™åˆ¶è§’åº¦èŒƒå›´ï¼ˆ-45Â° åˆ° 45Â°ï¼‰
        const maxAngle = math.toRadian(45);
        this.currentAngle = math.clamp(this.currentAngle, -maxAngle, maxAngle);
        
        // åº”ç”¨æ—‹è½¬åˆ°æ—‹è½¬ç»„
        const euler = new Vec3(0, 0, -math.toDegree(this.currentAngle));
        this.rotateGroup.setRotationFromEuler(euler);
    }
    
    /**
     * å‘å°„ç‚®å¼¹
     */
    public fire(targetPos: Vec3): void {
        // è§¦å‘åååŠ›
        this.recoil = this.RECOIL_DISTANCE;
        
        // åˆ›å»ºç‚®å¼¹
        const bullet = instantiate(this.bulletPrefab);
        
        // è®¡ç®—ç‚®å£ä½ç½®
        const muzzlePos = this.calculateMuzzlePosition();
        bullet.setPosition(muzzlePos);
        
        // ç‚®å¼¹é£å‘ç›®æ ‡
        const bulletEntity = bullet.getComponent(BulletEntity);
        bulletEntity.flyTo(targetPos);
        
        // æ·»åŠ åˆ°åœºæ™¯
        this.node.parent.addChild(bullet);
    }
    
    /**
     * è®¡ç®—ç‚®å£ä½ç½®
     */
    private calculateMuzzlePosition(): Vec3 {
        const cannonPos = this.node.getWorldPosition();
        const x = cannonPos.x + Math.sin(this.currentAngle) * this.MUZZLE_LENGTH;
        const y = cannonPos.y + Math.cos(this.currentAngle) * this.MUZZLE_LENGTH;
        
        return new Vec3(x, y, 0);
    }
    
    /**
     * æ›´æ–°åååŠ›
     */
    private updateRecoil(deltaTime: number): void {
        if (this.recoil > 0.1) {
            this.recoil *= this.RECOIL_DECAY;
            
            // åº”ç”¨åååˆ°æ—‹è½¬ç»„ï¼ˆæ²¿ç‚®ç®¡æ–¹å‘åé€€ï¼‰
            const offsetX = -Math.sin(this.currentAngle) * this.recoil;
            const offsetY = -Math.cos(this.currentAngle) * this.recoil;
            
            this.rotateGroup.setPosition(offsetX, offsetY, 0);
        } else {
            this.recoil = 0;
            this.rotateGroup.setPosition(0, 0, 0);
        }
    }
    
    /**
     * æ›´æ–°å¼•ä¿¡æ‘†åŠ¨ï¼ˆç‰©ç†æ¨¡æ‹Ÿï¼‰
     */
    private updateFuse(deltaTime: number): void {
        const gravity = 0.3; // é‡åŠ›å½±å“
        const damping = 0.95; // é˜»å°¼ç³»æ•°
        
        // ä¸–ç•Œä¸‹æ–¹å‘ï¼ˆ90Â° = Ï€/2ï¼‰
        const worldDown = Math.PI / 2;
        
        // ç›¸å¯¹äºç‚®ç®¡çš„ç›®æ ‡è§’åº¦
        const targetAngle = worldDown - this.currentAngle;
        
        // è§’åŠ é€Ÿåº¦ï¼ˆæ¢å¤åŠ›ï¼‰
        const angularAcceleration = Math.sin(targetAngle - this.fuseAngle) * gravity;
        
        // æ›´æ–°è§’é€Ÿåº¦
        this.fuseAngularVelocity += angularAcceleration;
        this.fuseAngularVelocity *= damping;
        
        // æ›´æ–°è§’åº¦
        this.fuseAngle += this.fuseAngularVelocity;
        
        // æ¸²æŸ“å¼•ä¿¡
        this.renderFuse();
    }
    
    /**
     * æ¸²æŸ“å¼•ä¿¡
     */
    private renderFuse(): void {
        const graphics = this.fuse.getComponent(Graphics);
        graphics.clear();
        
        const attachX = 18;
        const attachY = -60;
        const length = 12;
        
        // è®¡ç®—æœ«ç«¯ä½ç½®
        const endX = attachX + Math.sin(this.fuseAngle) * length;
        const endY = attachY + Math.cos(this.fuseAngle) * length;
        
        // ç»˜åˆ¶å¼•ä¿¡ç»³å­
        graphics.lineWidth = 2;
        graphics.strokeColor = new Color(62, 39, 35);
        graphics.moveTo(attachX, attachY);
        graphics.lineTo(endX, endY);
        graphics.stroke();
        
        // æ›´æ–°ç²’å­ä½ç½®
        this.fuseParticles.node.setPosition(endX, endY, 0);
        
        // è®¾ç½®ç²’å­æ–¹å‘ï¼ˆæ²¿å¼•ä¿¡å»¶ä¼¸æ–¹å‘ï¼‰
        const particleAngle = this.fuseAngle;
        // TODO: è®¾ç½®ç²’å­ç³»ç»Ÿçš„æ–¹å‘
    }
    
    /**
     * æ¸²æŸ“ç‚®ç®¡ï¼ˆæ›´æ–°è§†è§‰æ•ˆæœï¼‰
     */
    private renderCannon(): void {
        // åŸºåº§å§‹ç»ˆæ°´å¹³ï¼ˆä¸å—æ—‹è½¬å½±å“ï¼‰
        this.base.setRotationFromEuler(0, 0, 0);
        
        // å…¶ä»–éƒ¨ä»¶è·Ÿéšæ—‹è½¬ç»„
    }
}
```

---

## 4ï¸âƒ£ ç²’å­ç³»ç»Ÿå®ç°

### 4.1 çˆ†ç‚¸ç²’å­ç³»ç»Ÿ

```typescript
// assets/scripts/systems/ExplosionSystem.ts
import { _decorator, Component, Node, Prefab, instantiate, Vec3, 
         ParticleSystem2D, Label, tween, Color } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('ExplosionSystem')
export class ExplosionSystem extends Component {
    @property(Prefab)
    explosionPrefab: Prefab = null;
    
    @property(Node)
    explosionsContainer: Node = null;
    
    @property(Prefab)
    meaningLabelPrefab: Prefab = null;
    
    /**
     * åˆå§‹åŒ–
     */
    public initialize(): void {
        if (!this.explosionsContainer) {
            this.explosionsContainer = new Node('ExplosionsContainer');
            this.node.addChild(this.explosionsContainer);
        }
    }
    
    /**
     * åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
     */
    public createExplosion(position: Vec3, meaning: string): void {
        // 1. åˆ›å»ºç²’å­çˆ†ç‚¸
        this.createParticleExplosion(position);
        
        // 2. åˆ›å»ºä¸­æ–‡ç¿»è¯‘çˆ†ç‚¸åŠ¨ç”»
        this.createMeaningExplosion(position, meaning);
    }
    
    /**
     * åˆ›å»ºç²’å­çˆ†ç‚¸
     */
    private createParticleExplosion(position: Vec3): void {
        const explosion = instantiate(this.explosionPrefab);
        this.explosionsContainer.addChild(explosion);
        explosion.setWorldPosition(position);
        
        // è·å–ç²’å­ç³»ç»Ÿç»„ä»¶
        const particleSystem = explosion.getComponent(ParticleSystem2D);
        
        // é…ç½®ç²’å­å‚æ•°
        particleSystem.duration = 0.5; // æŒç»­æ—¶é—´
        particleSystem.life = 1.0; // ç²’å­ç”Ÿå‘½
        particleSystem.lifeVar = 0.3; // ç”Ÿå‘½å˜åŒ–
        particleSystem.startSize = 8; // èµ·å§‹å¤§å°
        particleSystem.startSizeVar = 4; // å¤§å°å˜åŒ–
        particleSystem.endSize = 0; // ç»“æŸå¤§å°
        particleSystem.angle = 90; // å‘å°„è§’åº¦
        particleSystem.angleVar = 360; // è§’åº¦å˜åŒ–ï¼ˆå…¨æ–¹å‘ï¼‰
        particleSystem.speed = 200; // é€Ÿåº¦
        particleSystem.speedVar = 50; // é€Ÿåº¦å˜åŒ–
        particleSystem.gravity = new Vec3(0, -100, 0); // é‡åŠ›
        
        // å¤šå½©é¢œè‰²ï¼ˆ6ç§é¢œè‰²ï¼‰
        const colors = [
            new Color(255, 0, 0),     // çº¢è‰²
            new Color(255, 165, 0),   // æ©™è‰²
            new Color(255, 255, 0),   // é»„è‰²
            new Color(0, 255, 0),     // ç»¿è‰²
            new Color(0, 0, 255),     // è“è‰²
            new Color(238, 130, 238)  // ç´«è‰²
        ];
        
        // éšæœºé€‰æ‹©é¢œè‰²
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        particleSystem.startColor = randomColor;
        particleSystem.endColor = new Color(randomColor.r, randomColor.g, randomColor.b, 0);
        
        // å¯åŠ¨ç²’å­ç³»ç»Ÿ
        particleSystem.resetSystem();
        
        // 1.5ç§’åé”€æ¯
        this.scheduleOnce(() => {
            explosion.destroy();
        }, 1.5);
    }
    
    /**
     * åˆ›å»ºä¸­æ–‡ç¿»è¯‘çˆ†ç‚¸åŠ¨ç”»
     */
    private createMeaningExplosion(position: Vec3, meaning: string): void {
        const meaningNode = instantiate(this.meaningLabelPrefab);
        this.explosionsContainer.addChild(meaningNode);
        meaningNode.setWorldPosition(position);
        
        // è·å– Label ç»„ä»¶
        const label = meaningNode.getComponent(Label);
        label.string = meaning;
        label.fontSize = 48; // åˆå§‹å­—ä½“å¤§å°
        label.color = new Color(255, 215, 0); // é‡‘é»„è‰²
        
        // è®¾ç½®æè¾¹
        label.enableOutline = true;
        label.outlineWidth = 2;
        label.outlineColor = new Color(0, 0, 0);
        
        // åŠ¨ç”»åºåˆ—ï¼šæ”¾å¤§ â†’ æ˜¾ç¤º â†’ æ·¡å‡º
        tween(meaningNode)
            // ä» 0.5 å€å¿«é€Ÿæ”¾å¤§åˆ° 2.5 å€
            .set({ scale: new Vec3(0.5, 0.5, 1) })
            .to(0.3, { scale: new Vec3(2.5, 2.5, 1) }, { easing: 'backOut' })
            // ä¿æŒæ˜¾ç¤º 1 ç§’
            .delay(1.0)
            // æ·¡å‡º
            .to(0.5, { 
                scale: new Vec3(3.0, 3.0, 1),
                position: new Vec3(position.x, position.y + 50, 0)
            })
            .call(() => {
                // é”€æ¯èŠ‚ç‚¹
                meaningNode.destroy();
            })
            .start();
        
        // é€æ˜åº¦åŠ¨ç”»
        const uiOpacity = meaningNode.addComponent(UIOpacity);
        tween(uiOpacity)
            .delay(1.3)
            .to(0.5, { opacity: 0 })
            .start();
    }
    
    /**
     * æ¯å¸§æ›´æ–°
     */
    public update(deltaTime: number): void {
        // ç²’å­ç³»ç»Ÿè‡ªåŠ¨æ›´æ–°ï¼Œæ— éœ€æ‰‹åŠ¨å¤„ç†
    }
    
    /**
     * æ¸…ç†
     */
    public cleanup(): void {
        this.explosionsContainer.removeAllChildren();
    }
}
```

### 4.2 ç‚®å¼¹å®ä½“

```typescript
// assets/scripts/entities/BulletEntity.ts
import { _decorator, Component, Node, Vec3, Sprite, Color, Graphics,
         tween, ParticleSystem2D } from 'cc';
const { ccclass, property } = _decorator;

@ccclass('BulletEntity')
export class BulletEntity extends Component {
    @property(Sprite)
    outerGlow: Sprite = null; // å¤–å±‚å…‰æ™•
    
    @property(Sprite)
    middleFire: Sprite = null; // ä¸­å±‚ç«çƒ
    
    @property(Sprite)
    innerCore: Sprite = null; // å†…æ ¸
    
    @property(ParticleSystem2D)
    flameParticles: ParticleSystem2D = null; // ç«ç„°ç²’å­
    
    @property(Node)
    trail: Node = null; // ç«ç„°å°¾è¿¹
    
    private velocity: Vec3 = new Vec3();
    private rotationSpeed: number = 0.3; // æ—‹è½¬é€Ÿåº¦
    private trailPoints: Vec3[] = [];
    private readonly MAX_TRAIL_POINTS = 20;
    private readonly SPEED = 15; // åƒç´ /å¸§
    
    /**
     * åˆå§‹åŒ–ç«çƒè§†è§‰
     */
    protected onLoad(): void {
        this.setupVisuals();
        this.setupTrail();
    }
    
    /**
     * è®¾ç½®è§†è§‰æ•ˆæœ
     */
    private setupVisuals(): void {
        // å¤–å±‚å…‰æ™•ï¼ˆçº¢è‰²ï¼‰
        this.outerGlow.color = new Color(255, 100, 0);
        this.outerGlow.node.setScale(2.0, 2.0, 1);
        
        // ä¸­å±‚ç«çƒï¼ˆæ©™è‰²ï¼‰
        this.middleFire.color = new Color(255, 200, 0);
        this.middleFire.node.setScale(1.25, 1.25, 1);
        
        // å†…æ ¸ï¼ˆäº®é»„è‰²ï¼‰
        this.innerCore.color = new Color(255, 255, 200);
        this.innerCore.node.setScale(0.625, 0.625, 1);
        
        // å¯åŠ¨ç«ç„°ç²’å­
        this.flameParticles.resetSystem();
    }
    
    /**
     * è®¾ç½®å°¾è¿¹
     */
    private setupTrail(): void {
        // åˆå§‹åŒ–å°¾è¿¹ç‚¹
        for (let i = 0; i < this.MAX_TRAIL_POINTS; i++) {
            this.trailPoints.push(new Vec3());
        }
    }
    
    /**
     * é£å‘ç›®æ ‡
     */
    public flyTo(targetPos: Vec3): void {
        const currentPos = this.node.getWorldPosition();
        const direction = new Vec3();
        Vec3.subtract(direction, targetPos, currentPos);
        direction.normalize();
        
        this.velocity = direction.multiplyScalar(this.SPEED);
    }
    
    /**
     * æ¯å¸§æ›´æ–°
     */
    protected update(deltaTime: number): void {
        // ç§»åŠ¨
        const pos = this.node.position;
        pos.add(this.velocity.multiplyScalar(deltaTime * 60));
        this.node.setPosition(pos);
        
        // æ—‹è½¬ï¼ˆç«ç„°çº¹ç†ï¼‰
        const currentRotation = this.node.eulerAngles;
        this.node.setRotationFromEuler(
            currentRotation.x,
            currentRotation.y,
            currentRotation.z + this.rotationSpeed
        );
        
        // æ›´æ–°å°¾è¿¹
        this.updateTrail();
    }
    
    /**
     * æ›´æ–°å°¾è¿¹
     */
    private updateTrail(): void {
        const currentPos = this.node.getWorldPosition();
        
        // ç§»åŠ¨æ‰€æœ‰ç‚¹
        for (let i = this.trailPoints.length - 1; i > 0; i--) {
            this.trailPoints[i].set(this.trailPoints[i - 1]);
        }
        
        // æ·»åŠ æ–°ç‚¹
        this.trailPoints[0].set(currentPos);
        
        // ç»˜åˆ¶å°¾è¿¹
        this.drawTrail();
    }
    
    /**
     * ç»˜åˆ¶å°¾è¿¹
     */
    private drawTrail(): void {
        const graphics = this.trail.getComponent(Graphics);
        if (!graphics) return;
        
        graphics.clear();
        
        // ç»˜åˆ¶æ¸å˜å°¾è¿¹
        for (let i = 0; i < this.trailPoints.length - 1; i++) {
            const alpha = (this.trailPoints.length - i) / this.trailPoints.length;
            const size = 12 * alpha;
            
            // æ¸å˜é¢œè‰²ï¼ˆæ©™é»„ â†’ æ©™çº¢ï¼‰
            const r = 255;
            const g = 200 - (i / this.trailPoints.length) * 100;
            const b = 0;
            
            graphics.fillColor = new Color(r, g, b, alpha * 255);
            graphics.circle(
                this.trailPoints[i].x,
                this.trailPoints[i].y,
                size
            );
            graphics.fill();
        }
    }
    
    /**
     * æ£€æŸ¥ç¢°æ’
     */
    public checkCollision(targetPos: Vec3): boolean {
        const currentPos = this.node.getWorldPosition();
        const distance = Vec3.distance(currentPos, targetPos);
        
        return distance < 20; // ç¢°æ’è·ç¦»
    }
    
    /**
     * é”€æ¯
     */
    public destroy(): void {
        this.node.destroy();
    }
}
```

---

## 5ï¸âƒ£ åŠ¨ç”»ç³»ç»Ÿå®ç°

### 5.1 ä½¿ç”¨ Tween åŠ¨ç”»

```typescript
// å¸¸ç”¨åŠ¨ç”»ç¤ºä¾‹

// 1. ä½ç½®åŠ¨ç”»
tween(node)
    .to(1, { position: new Vec3(100, 100, 0) })
    .start();

// 2. ç¼©æ”¾åŠ¨ç”»
tween(node)
    .to(0.5, { scale: new Vec3(1.5, 1.5, 1) })
    .start();

// 3. æ—‹è½¬åŠ¨ç”»
tween(node)
    .to(1, { eulerAngles: new Vec3(0, 0, 360) })
    .start();

// 4. é€æ˜åº¦åŠ¨ç”»
const uiOpacity = node.addComponent(UIOpacity);
tween(uiOpacity)
    .to(0.5, { opacity: 0 })
    .start();

// 5. é“¾å¼åŠ¨ç”»
tween(node)
    .to(0.5, { position: new Vec3(100, 0, 0) })
    .delay(0.5)
    .to(0.5, { scale: new Vec3(2, 2, 1) })
    .call(() => {
        console.log('åŠ¨ç”»å®Œæˆ');
    })
    .start();

// 6. å¾ªç¯åŠ¨ç”»
tween(node)
    .to(1, { position: new Vec3(100, 0, 0) })
    .to(1, { position: new Vec3(0, 0, 0) })
    .union()
    .repeatForever()
    .start();

// 7. ç¼“åŠ¨å‡½æ•°
tween(node)
    .to(1, { position: new Vec3(100, 0, 0) }, { easing: 'backOut' })
    .start();

// å¸¸ç”¨ç¼“åŠ¨å‡½æ•°ï¼š
// - linear
// - sineIn, sineOut, sineInOut
// - backIn, backOut, backInOut
// - bounceIn, bounceOut, bounceInOut
// - elasticIn, elasticOut, elasticInOut
```

---

## 6ï¸âƒ£ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 6.1 æ‰¹å¤„ç†

```typescript
// åˆå¹¶ç›¸åŒæè´¨çš„ Sprite
// åœ¨ç¼–è¾‘å™¨ä¸­è®¾ç½® Sprite çš„ Atlas å±æ€§
```

### 6.2 å¯¹è±¡æ± 

```typescript
// ä½¿ç”¨å¯¹è±¡æ± ç®¡ç†é¢‘ç¹åˆ›å»º/é”€æ¯çš„å¯¹è±¡
private bulletPool: NodePool = new NodePool();

getBullet(): Node {
    return this.bulletPool.size() > 0 
        ? this.bulletPool.get() 
        : instantiate(this.bulletPrefab);
}

recycleBullet(bullet: Node): void {
    this.bulletPool.put(bullet);
}
```

### 6.3 å‡å°‘ Draw Call

- ä½¿ç”¨å›¾é›†ï¼ˆAtlasï¼‰åˆå¹¶çº¹ç†
- å‡å°‘èŠ‚ç‚¹å±‚çº§
- åˆå¹¶é™æ€èŠ‚ç‚¹
- ä½¿ç”¨æ‰¹å¤„ç†

---

## 7ï¸âƒ£ è°ƒè¯•å·¥å…·

### å¼€å¯æ€§èƒ½ç»Ÿè®¡

```typescript
// åœ¨ start() ä¸­
director.getScheduler().enableForTarget(this);
game.frameRate = 60;

// æ˜¾ç¤º FPS
if (DEBUG) {
    profiler.showStats();
}
```

---

## éªŒè¯æ¸…å•

- [ ] å•è¯èŠ‚ç‚¹æ­£ç¡®æ˜¾ç¤º
- [ ] ç‚®ç®¡äº”å±‚ç»“æ„å®Œæ•´
- [ ] ç‚®ç®¡ç„å‡†æµç•…
- [ ] åååŠ›æ•ˆæœæ˜æ˜¾
- [ ] å¼•ä¿¡ç‰©ç†æ‘†åŠ¨è‡ªç„¶
- [ ] ç«çƒä¸‰å±‚ç»“æ„æ­£ç¡®
- [ ] ç«ç„°å°¾è¿¹æµç•…
- [ ] ç²’å­çˆ†ç‚¸å¤šå½©
- [ ] ä¸­æ–‡ç¿»è¯‘çˆ†ç‚¸åŠ¨ç”»å®Œæ•´
- [ ] åŠ¨ç”»æµç•…ï¼ˆ60 FPSï¼‰

---

**æ¸²æŸ“ç³»ç»Ÿæ”¹é€ å®Œæˆï¼** âœ…

ä¸‹ä¸€æ­¥ï¼šé˜…è¯» [07_UIç³»ç»Ÿé‡å»º.md](./07_UIç³»ç»Ÿé‡å»º.md)




