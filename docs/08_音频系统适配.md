# éŸ³é¢‘ç³»ç»Ÿé€‚é…

## ğŸ“‹ æœ¬æ–‡æ¡£å†…å®¹

- TTS æœåŠ¡ Cocos é€‚é…
- éŸ³é¢‘ç¼“å­˜ç³»ç»Ÿå®ç°
- éŸ³é¢‘æ’­æ”¾ç®¡ç†
- ç§»åŠ¨ç«¯å…¼å®¹æ€§å¤„ç†

---

## 1ï¸âƒ£ éŸ³é¢‘ç³»ç»Ÿå¯¹æ¯”

### 1.1 HTML5 vs Cocos éŸ³é¢‘

| ç‰¹æ€§ | HTML5 Audio | Cocos Creator |
|------|------------|---------------|
| **æ’­æ”¾éŸ³é¢‘** | `new Audio(url)` | `cc.audioEngine.play(clip)` |
| **éŸ³é‡æ§åˆ¶** | `audio.volume = 0.5` | `audioID, volume` å‚æ•° |
| **æš‚åœ/æ¢å¤** | `audio.pause()`<br>`audio.play()` | `audioEngine.pause(audioID)`<br>`audioEngine.resume(audioID)` |
| **åœæ­¢** | `audio.pause()`<br>`audio.currentTime = 0` | `audioEngine.stop(audioID)` |
| **å¾ªç¯æ’­æ”¾** | `audio.loop = true` | `play(clip, true)` |
| **èµ„æºåŠ è½½** | ç›´æ¥ URL | `resources.load()` |
| **å¤šå®ä¾‹** | åˆ›å»ºå¤šä¸ª Audio å¯¹è±¡ | è‡ªåŠ¨ç®¡ç† |

---

## 2ï¸âƒ£ TTSService è¿ç§»

### 2.1 åŸå§‹ TTSService ç»“æ„

åŸé¡¹ç›®çš„ TTS æœåŠ¡ç‰¹ç‚¹ï¼š
- å¤šæä¾›å•†é™çº§ï¼ˆç™¾åº¦/æœ‰é“/Bing/Web Speech APIï¼‰
- iOS è®¾å¤‡ä¼˜åŒ–ï¼ˆä¼˜å…ˆä½¿ç”¨ Web Speech APIï¼‰
- éŸ³é¢‘ç¼“å­˜ç³»ç»Ÿï¼ˆIndexedDB + æœ¬åœ°æ–‡ä»¶ï¼‰
- æ¸¸æˆæ¨¡å¼å·®å¼‚åŒ–æ’­æ”¾ï¼ˆä¼‘é—²/æŒ‘æˆ˜æ¨¡å¼ï¼‰
- è¶…æ—¶æ§åˆ¶å’Œå–æ¶ˆä»¤ç‰Œç³»ç»Ÿ

### 2.2 Cocos Creator é€‚é…æ–¹æ¡ˆ

```typescript
// assets/scripts/utils/TTSService.ts
import { _decorator, Component, AudioClip, audioEngine, resources, sys } from 'cc';
const { ccclass } = _decorator;

/**
 * TTS æä¾›å•†æ¥å£
 */
interface TTSProvider {
    name: string;
    priority: number;
    isAvailable: () => Promise<boolean>;
    speak: (word: string, volume: number) => Promise<number>;
}

/**
 * TTS æœåŠ¡ï¼ˆCocos Creator ç‰ˆæœ¬ï¼‰
 */
@ccclass('TTSService')
export class TTSService extends Component {
    private static _instance: TTSService = null;
    
    // TTS æä¾›å•†
    private providers: TTSProvider[] = [];
    private currentProvider: TTSProvider | null = null;
    
    // å–æ¶ˆä»¤ç‰Œç³»ç»Ÿ
    private currentSpeakId: number = 0;
    private activeSpeakIds: Set<number> = new Set();
    private cancelledSpeakIds: Set<number> = new Set();
    
    // éŸ³é¢‘ç¼“å­˜
    private cacheManager: AudioCacheManager | null = null;
    private cacheEnabled: boolean = true;
    
    // æ’­æ”¾çŠ¶æ€
    private currentAudioID: number = -1;
    private repeatTimer: number = -1;
    
    /**
     * å•ä¾‹æ¨¡å¼
     */
    public static getInstance(): TTSService {
        if (!this._instance) {
            const node = new Node('TTSService');
            this._instance = node.addComponent(TTSService);
            director.addPersistRootNode(node);
        }
        return this._instance;
    }
    
    /**
     * åˆå§‹åŒ–
     */
    public async initialize(): Promise<void> {
        console.log('TTSService: åˆå§‹åŒ–');
        
        // 1. åˆå§‹åŒ–ç¼“å­˜ç®¡ç†å™¨
        if (this.cacheEnabled) {
            this.cacheManager = AudioCacheManager.getInstance();
            await this.cacheManager.initialize();
        }
        
        // 2. æ³¨å†Œ TTS æä¾›å•†
        this.registerProviders();
        
        // 3. æµ‹è¯•æä¾›å•†å¯ç”¨æ€§
        await this.testProviders();
        
        console.log('âœ… TTS æœåŠ¡åˆå§‹åŒ–å®Œæˆ');
    }
    
    /**
     * æ³¨å†Œ TTS æä¾›å•†
     */
    private registerProviders(): void {
        const isIOS = sys.os === sys.OS.IOS;
        
        if (isIOS) {
            // iOS è®¾å¤‡ï¼šä¼˜å…ˆä½¿ç”¨ Web Speech API
            this.providers = [
                this.createWebSpeechProvider(1),
                this.createYoudaoProvider(2),
                this.createBaiduProvider(3)
            ];
        } else {
            // å…¶ä»–è®¾å¤‡ï¼šä¼˜å…ˆä½¿ç”¨ç¬¬ä¸‰æ–¹ TTS
            this.providers = [
                this.createBaiduProvider(1),
                this.createYoudaoProvider(2),
                this.createBingProvider(3),
                this.createWebSpeechProvider(4)
            ];
        }
    }
    
    /**
     * åˆ›å»ºç™¾åº¦ TTS æä¾›å•†
     */
    private createBaiduProvider(priority: number): TTSProvider {
        return {
            name: 'ç™¾åº¦ç¿»è¯‘ TTS',
            priority,
            isAvailable: async () => {
                // æµ‹è¯•æ˜¯å¦å¯è®¿é—®
                try {
                    const testUrl = 'https://fanyi.baidu.com/gettts?lan=en&text=test';
                    const response = await fetch(testUrl, { method: 'HEAD' });
                    return response.ok;
                } catch {
                    return false;
                }
            },
            speak: async (word: string, volume: number) => {
                const url = `https://fanyi.baidu.com/gettts?lan=en&text=${encodeURIComponent(word)}&spd=5&source=web`;
                return await this.playAudioFromURL(url, 'baidu', word, volume);
            }
        };
    }
    
    /**
     * åˆ›å»ºæœ‰é“ TTS æä¾›å•†
     */
    private createYoudaoProvider(priority: number): TTSProvider {
        return {
            name: 'æœ‰é“æ™ºäº‘ TTS',
            priority,
            isAvailable: async () => {
                try {
                    const testUrl = 'https://dict.youdao.com/dictvoice?audio=test&type=1';
                    const response = await fetch(testUrl, { method: 'HEAD' });
                    return response.ok;
                } catch {
                    return false;
                }
            },
            speak: async (word: string, volume: number) => {
                const url = `https://dict.youdao.com/dictvoice?audio=${encodeURIComponent(word)}&type=1`;
                return await this.playAudioFromURL(url, 'youdao', word, volume);
            }
        };
    }
    
    /**
     * åˆ›å»º Bing TTS æä¾›å•†
     */
    private createBingProvider(priority: number): TTSProvider {
        return {
            name: 'å¾®è½¯ Bing TTS',
            priority,
            isAvailable: async () => {
                // Bing TTS é€šå¸¸å¯ç”¨
                return true;
            },
            speak: async (word: string, volume: number) => {
                const url = `https://www.bing.com/tts/v1?text=${encodeURIComponent(word)}&lang=en-GB`;
                return await this.playAudioFromURL(url, 'bing', word, volume);
            }
        };
    }
    
    /**
     * åˆ›å»º Web Speech API æä¾›å•†
     */
    private createWebSpeechProvider(priority: number): TTSProvider {
        return {
            name: 'Web Speech API',
            priority,
            isAvailable: async () => {
                return 'speechSynthesis' in window;
            },
            speak: async (word: string, volume: number) => {
                return new Promise((resolve, reject) => {
                    if (!('speechSynthesis' in window)) {
                        reject(new Error('Web Speech API ä¸å¯ç”¨'));
                        return;
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(word);
                    utterance.lang = 'en-GB'; // è‹±å¼è‹±è¯­
                    utterance.volume = volume;
                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;
                    
                    utterance.onend = () => resolve(1); // è¿”å›è™šæ‹Ÿ audioID
                    utterance.onerror = (e) => reject(e);
                    
                    window.speechSynthesis.speak(utterance);
                });
            }
        };
    }
    
    /**
     * ä» URL æ’­æ”¾éŸ³é¢‘ï¼ˆå¸¦ç¼“å­˜ï¼‰
     */
    private async playAudioFromURL(url: string, provider: string, 
                                   word: string, volume: number): Promise<number> {
        // å¦‚æœå¯ç”¨ç¼“å­˜
        if (this.cacheEnabled && this.cacheManager && word) {
            // 1. æ£€æŸ¥ç¼“å­˜
            if (await this.cacheManager.hasCache(word, provider)) {
                const cachedClip = await this.cacheManager.getCache(word, provider);
                return this.playAudioClip(cachedClip, volume);
            }
            
            // 2. ä¸‹è½½éŸ³é¢‘
            const audioBlob = await this.downloadAudio(url);
            
            // 3. ä¿å­˜ç¼“å­˜ï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡æ’­æ”¾ï¼‰
            this.cacheManager.saveCache(word, provider, audioBlob);
            
            // 4. è½¬æ¢ä¸º AudioClip æ’­æ”¾
            const clip = await this.blobToAudioClip(audioBlob);
            return this.playAudioClip(clip, volume);
        }
        
        // æœªå¯ç”¨ç¼“å­˜ï¼Œç›´æ¥åŠ è½½è¿œç¨‹éŸ³é¢‘
        return new Promise((resolve, reject) => {
            assetManager.loadRemote(url, { ext: '.mp3' }, (err, clip: AudioClip) => {
                if (err) {
                    reject(err);
                } else {
                    const audioID = this.playAudioClip(clip, volume);
                    resolve(audioID);
                }
            });
        });
    }
    
    /**
     * æ’­æ”¾ AudioClip
     */
    private playAudioClip(clip: AudioClip, volume: number): number {
        const audioID = audioEngine.play(clip, false, volume);
        this.currentAudioID = audioID;
        return audioID;
    }
    
    /**
     * ä¸‹è½½éŸ³é¢‘
     */
    private async downloadAudio(url: string): Promise<Blob> {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return await response.blob();
    }
    
    /**
     * Blob è½¬ AudioClip
     */
    private async blobToAudioClip(blob: Blob): Promise<AudioClip> {
        // åœ¨ Cocos Creator ä¸­ï¼Œéœ€è¦é€šè¿‡ URL åŠ è½½
        const blobUrl = URL.createObjectURL(blob);
        
        return new Promise((resolve, reject) => {
            assetManager.loadRemote(blobUrl, { ext: '.mp3' }, (err, clip: AudioClip) => {
                URL.revokeObjectURL(blobUrl);
                
                if (err) {
                    reject(err);
                } else {
                    resolve(clip);
                }
            });
        });
    }
    
    /**
     * æµ‹è¯•æä¾›å•†
     */
    private async testProviders(): Promise<void> {
        console.log('æµ‹è¯• TTS æä¾›å•†...');
        
        for (const provider of this.providers) {
            const available = await provider.isAvailable();
            console.log(`${provider.name}: ${available ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨'}`);
            
            if (available && !this.currentProvider) {
                this.currentProvider = provider;
            }
        }
        
        if (!this.currentProvider) {
            console.warn('âš ï¸ æ²¡æœ‰å¯ç”¨çš„ TTS æä¾›å•†');
        }
    }
    
    /**
     * æœ—è¯»å•è¯
     */
    public async speak(word: string, options?: any): Promise<void> {
        const speakId = ++this.currentSpeakId;
        this.activeSpeakIds.add(speakId);
        
        try {
            // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
            if (this.cancelledSpeakIds.has(speakId)) {
                return;
            }
            
            const volume = options?.volume || 1.0;
            
            // å°è¯•æ‰€æœ‰æä¾›å•†
            for (const provider of this.providers) {
                try {
                    const audioID = await provider.speak(word, volume);
                    this.currentAudioID = audioID;
                    
                    console.log(`âœ… æ’­æ”¾æˆåŠŸ: ${word} (${provider.name})`);
                    break;
                    
                } catch (error) {
                    console.warn(`âš ï¸ ${provider.name} å¤±è´¥:`, error);
                    continue;
                }
            }
            
        } finally {
            this.activeSpeakIds.delete(speakId);
            this.cancelledSpeakIds.delete(speakId);
        }
    }
    
    /**
     * åœæ­¢æ’­æ”¾
     */
    public stop(setCancelled: boolean = true): void {
        // åœæ­¢å½“å‰éŸ³é¢‘
        if (this.currentAudioID !== -1) {
            audioEngine.stop(this.currentAudioID);
            this.currentAudioID = -1;
        }
        
        // åœæ­¢ Web Speech API
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
        }
        
        // æ¸…é™¤å®šæ—¶å™¨
        if (this.repeatTimer !== -1) {
            this.unschedule(this.repeatTimer);
            this.repeatTimer = -1;
        }
        
        // æ ‡è®°å–æ¶ˆ
        if (setCancelled) {
            this.activeSpeakIds.forEach(id => {
                this.cancelledSpeakIds.add(id);
            });
        }
    }
    
    /**
     * é‡å¤æ’­æ”¾
     */
    public startRepeat(word: string, interval: number = 5000): void {
        this.stopRepeat();
        
        this.repeatTimer = setInterval(() => {
            this.speak(word);
        }, interval);
    }
    
    /**
     * åœæ­¢é‡å¤
     */
    public stopRepeat(): void {
        if (this.repeatTimer !== -1) {
            clearInterval(this.repeatTimer);
            this.repeatTimer = -1;
        }
    }
    
    /**
     * æ¸…ç†
     */
    public cleanup(): void {
        this.stop();
        this.stopRepeat();
        this.cacheManager?.clearBlobUrlCache();
    }
}
```

---

## 3ï¸âƒ£ éŸ³é¢‘ç¼“å­˜ç®¡ç†å™¨

### 3.1 AudioCacheManager å®ç°

```typescript
// assets/scripts/utils/AudioCacheManager.ts
import { AudioClip, sys } from 'cc';

/**
 * éŸ³é¢‘ç¼“å­˜ç®¡ç†å™¨ï¼ˆCocos Creator ç‰ˆæœ¬ï¼‰
 */
export class AudioCacheManager {
    private static _instance: AudioCacheManager = null;
    
    private dbName: string = 'WordTetrisAudioCache';
    private dbVersion: number = 1;
    private storeName: string = 'audios';
    private db: IDBDatabase | null = null;
    
    private blobUrlCache: Map<string, string> = new Map();
    private isLocal: boolean = false;
    
    /**
     * å•ä¾‹æ¨¡å¼
     */
    public static getInstance(): AudioCacheManager {
        if (!this._instance) {
            this._instance = new AudioCacheManager();
        }
        return this._instance;
    }
    
    /**
     * åˆå§‹åŒ–
     */
    public async initialize(): Promise<void> {
        // æ£€æµ‹ç¯å¢ƒ
        this.isLocal = this.isLocalDevelopment();
        
        // åˆå§‹åŒ– IndexedDB
        if (sys.isBrowser) {
            await this.initDB();
        }
        
        console.log('âœ… éŸ³é¢‘ç¼“å­˜ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
        console.log(`   ç¯å¢ƒ: ${this.isLocal ? 'æœ¬åœ°å¼€å‘' : 'Webéƒ¨ç½²'}`);
    }
    
    /**
     * åˆå§‹åŒ– IndexedDB
     */
    private initDB(): Promise<void> {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = (event.target as IDBOpenDBRequest).result;
                
                if (!db.objectStoreNames.contains(this.storeName)) {
                    const store = db.createObjectStore(this.storeName, { 
                        keyPath: 'id', 
                        autoIncrement: true 
                    });
                    
                    // åˆ›å»ºå¤åˆç´¢å¼•
                    store.createIndex('word_provider', ['word', 'provider'], { unique: true });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    }
    
    /**
     * æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
     */
    public async hasCache(word: string, provider: string): Promise<boolean> {
        // 1. æ£€æŸ¥æœ¬åœ°æ–‡ä»¶
        if (this.isLocal) {
            const hasLocal = await this.checkLocalFile(word, provider);
            if (hasLocal) return true;
        }
        
        // 2. æ£€æŸ¥ IndexedDB
        if (this.db) {
            try {
                const data = await this.getFromDB(word, provider);
                return !!data;
            } catch {
                return false;
            }
        }
        
        return false;
    }
    
    /**
     * è·å–ç¼“å­˜
     */
    public async getCache(word: string, provider: string): Promise<AudioClip> {
        const cacheKey = `${word}_${provider}`;
        
        // 1. æ£€æŸ¥å†…å­˜ç¼“å­˜
        if (this.blobUrlCache.has(cacheKey)) {
            const blobUrl = this.blobUrlCache.get(cacheKey);
            return await this.loadAudioClipFromURL(blobUrl);
        }
        
        // 2. æ£€æŸ¥æœ¬åœ°æ–‡ä»¶
        if (this.isLocal) {
            const localPath = this.getLocalFilePath(word, provider);
            try {
                const clip = await this.loadLocalAudioClip(localPath);
                return clip;
            } catch {
                // ç»§ç»­å°è¯• IndexedDB
            }
        }
        
        // 3. ä» IndexedDB è¯»å–
        if (this.db) {
            const data = await this.getFromDB(word, provider);
            if (data && data.blob) {
                const blobUrl = URL.createObjectURL(data.blob);
                this.blobUrlCache.set(cacheKey, blobUrl);
                
                return await this.loadAudioClipFromURL(blobUrl);
            }
        }
        
        throw new Error('ç¼“å­˜ä¸å­˜åœ¨');
    }
    
    /**
     * ä¿å­˜ç¼“å­˜
     */
    public async saveCache(word: string, provider: string, audioBlob: Blob): Promise<void> {
        if (this.isLocal) {
            // æœ¬åœ°å¼€å‘ï¼šæç¤ºä¸‹è½½æ–‡ä»¶
            this.promptDownloadFile(word, provider, audioBlob);
        } else {
            // Web éƒ¨ç½²ï¼šä¿å­˜åˆ° IndexedDB
            await this.saveToDB(word, provider, audioBlob);
        }
    }
    
    /**
     * ä» IndexedDB è¯»å–
     */
    private getFromDB(word: string, provider: string): Promise<any> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.storeName], 'readonly');
            const store = transaction.objectStore(this.storeName);
            const index = store.index('word_provider');
            const request = index.get([word.toLowerCase(), provider.toLowerCase()]);
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
    
    /**
     * ä¿å­˜åˆ° IndexedDB
     */
    private saveToDB(word: string, provider: string, audioBlob: Blob): Promise<void> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);
            
            const data = {
                word: word.toLowerCase(),
                provider: provider.toLowerCase(),
                blob: audioBlob,
                timestamp: Date.now()
            };
            
            const request = store.add(data);
            
            request.onsuccess = () => {
                console.log(`ğŸ’¾ ä¿å­˜åˆ° IndexedDB: ${word}_${provider}`);
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }
    
    /**
     * æ£€æŸ¥æœ¬åœ°æ–‡ä»¶
     */
    private async checkLocalFile(word: string, provider: string): Promise<boolean> {
        const path = this.getLocalFilePath(word, provider);
        
        return new Promise((resolve) => {
            resources.load(path, AudioClip, (err) => {
                resolve(!err);
            });
        });
    }
    
    /**
     * åŠ è½½æœ¬åœ°éŸ³é¢‘æ–‡ä»¶
     */
    private loadLocalAudioClip(path: string): Promise<AudioClip> {
        return new Promise((resolve, reject) => {
            resources.load(path, AudioClip, (err, clip) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(clip);
                }
            });
        });
    }
    
    /**
     * ä» URL åŠ è½½ AudioClip
     */
    private loadAudioClipFromURL(url: string): Promise<AudioClip> {
        return new Promise((resolve, reject) => {
            assetManager.loadRemote(url, { ext: '.mp3' }, (err, clip: AudioClip) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(clip);
                }
            });
        });
    }
    
    /**
     * è·å–æœ¬åœ°æ–‡ä»¶è·¯å¾„
     */
    private getLocalFilePath(word: string, provider: string): string {
        return `audio/tts/${word.toLowerCase()}_${provider.toLowerCase()}`;
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦æœ¬åœ°å¼€å‘ç¯å¢ƒ
     */
    private isLocalDevelopment(): boolean {
        if (!sys.isBrowser) {
            return false;
        }
        
        const hostname = location.hostname;
        return hostname === 'localhost' || 
               hostname === '127.0.0.1' || 
               hostname === '' ||
               hostname.startsWith('192.168.') ||
               hostname.startsWith('10.');
    }
    
    /**
     * æç¤ºä¸‹è½½æ–‡ä»¶ï¼ˆæœ¬åœ°å¼€å‘ï¼‰
     */
    private promptDownloadFile(word: string, provider: string, audioBlob: Blob): void {
        const fileName = `${word.toLowerCase()}_${provider.toLowerCase()}.mp3`;
        
        console.log(`ğŸ’¡ å»ºè®®ä¸‹è½½æ–‡ä»¶: ${fileName}`);
        console.log(`   ä¿å­˜åˆ°: assets/resources/audio/tts/${fileName}`);
        
        // æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—
        if (!window['_audioCacheDownloadQueue']) {
            window['_audioCacheDownloadQueue'] = [];
        }
        
        window['_audioCacheDownloadQueue'].push({
            word,
            provider,
            blob: audioBlob,
            fileName
        });
    }
    
    /**
     * æ¸…ç©ºå†…å­˜ç¼“å­˜
     */
    public clearBlobUrlCache(): void {
        this.blobUrlCache.forEach(blobUrl => {
            URL.revokeObjectURL(blobUrl);
        });
        this.blobUrlCache.clear();
    }
    
    /**
     * è·å–ç¼“å­˜ç»Ÿè®¡
     */
    public async getStats(): Promise<any> {
        if (!this.db) {
            return { total: 0, totalSizeMB: '0', items: [] };
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.storeName], 'readonly');
            const store = transaction.objectStore(this.storeName);
            const request = store.getAll();
            
            request.onsuccess = () => {
                const items = request.result;
                let totalSize = 0;
                
                items.forEach(item => {
                    if (item.blob) {
                        totalSize += item.blob.size;
                    }
                });
                
                resolve({
                    total: items.length,
                    totalSizeMB: (totalSize / 1024 / 1024).toFixed(2),
                    items: items.map(item => ({
                        word: item.word,
                        provider: item.provider,
                        size: (item.blob?.size / 1024).toFixed(2) + ' KB',
                        date: new Date(item.timestamp).toLocaleString()
                    }))
                });
            };
            
            request.onerror = () => reject(request.error);
        });
    }
}
```

---

## 4ï¸âƒ£ æ¸¸æˆä¸­çš„éŸ³é¢‘é›†æˆ

### 4.1 GameManager ä¸­ä½¿ç”¨ TTS

```typescript
// assets/scripts/core/GameManager.ts
import { TTSService } from '../utils/TTSService';

@ccclass('GameManager')
export class GameManager extends Component {
    private ttsService: TTSService = null;
    
    protected async onLoad(): Promise<void> {
        // åˆå§‹åŒ– TTS æœåŠ¡
        this.ttsService = TTSService.getInstance();
        await this.ttsService.initialize();
    }
    
    /**
     * å•è¯å¼€å§‹ä¸‹é™æ—¶æ’­æ”¾è¯­éŸ³
     */
    private onWordReleased(word: WordEntity): void {
        const wordText = word.getWord();
        
        // ç«‹å³æ’­æ”¾ä¸€æ¬¡
        this.ttsService.speak(wordText);
        
        // æ¯ 5 ç§’é‡å¤æ’­æ”¾
        this.ttsService.startRepeat(wordText, 5000);
    }
    
    /**
     * å•è¯è¢«å‡»è½æˆ–å †å æ—¶åœæ­¢è¯­éŸ³
     */
    private onWordRemoved(): void {
        this.ttsService.stop();
        this.ttsService.stopRepeat();
    }
    
    /**
     * æ¸¸æˆæš‚åœæ—¶åœæ­¢è¯­éŸ³
     */
    public pauseGame(): void {
        this.isPaused = true;
        this.ttsService.stop();
    }
    
    /**
     * æ¸…ç†
     */
    protected onDestroy(): void {
        this.ttsService.cleanup();
    }
}
```

---

## 5ï¸âƒ£ éªŒè¯æ¸…å•

- [ ] TTS æœåŠ¡åˆå§‹åŒ–æˆåŠŸ
- [ ] å¤šæä¾›å•†é™çº§æ­£å¸¸å·¥ä½œ
- [ ] iOS è®¾å¤‡ä¼˜å…ˆä½¿ç”¨ Web Speech API
- [ ] éŸ³é¢‘ç¼“å­˜ç³»ç»Ÿå·¥ä½œæ­£å¸¸
- [ ] IndexedDB ç¼“å­˜æŒä¹…åŒ–
- [ ] æœ¬åœ°å¼€å‘ç¯å¢ƒæ–‡ä»¶æç¤º
- [ ] éŸ³é¢‘æ’­æ”¾æµç•…
- [ ] é‡å¤æ’­æ”¾æ­£å¸¸
- [ ] æš‚åœ/åœæ­¢åŠŸèƒ½æ­£å¸¸
- [ ] éŸ³é‡æ§åˆ¶æœ‰æ•ˆ

---

**éŸ³é¢‘ç³»ç»Ÿé€‚é…å®Œæˆï¼** âœ…

ä¸‹ä¸€æ­¥ï¼šé˜…è¯» [09_æµ‹è¯•éªŒè¯æ¸…å•.md](./09_æµ‹è¯•éªŒè¯æ¸…å•.md)




