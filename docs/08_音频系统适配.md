# 音频系统适配

## 📋 本文档内容

- TTS 服务 Cocos 适配
- 音频缓存系统实现
- 音频播放管理
- 移动端兼容性处理

---

## 1️⃣ 音频系统对比

### 1.1 HTML5 vs Cocos 音频

| 特性 | HTML5 Audio | Cocos Creator |
|------|------------|---------------|
| **播放音频** | `new Audio(url)` | `cc.audioEngine.play(clip)` |
| **音量控制** | `audio.volume = 0.5` | `audioID, volume` 参数 |
| **暂停/恢复** | `audio.pause()`<br>`audio.play()` | `audioEngine.pause(audioID)`<br>`audioEngine.resume(audioID)` |
| **停止** | `audio.pause()`<br>`audio.currentTime = 0` | `audioEngine.stop(audioID)` |
| **循环播放** | `audio.loop = true` | `play(clip, true)` |
| **资源加载** | 直接 URL | `resources.load()` |
| **多实例** | 创建多个 Audio 对象 | 自动管理 |

---

## 2️⃣ TTSService 迁移

### 2.1 原始 TTSService 结构

原项目的 TTS 服务特点：
- 多提供商降级（百度/有道/Bing/Web Speech API）
- iOS 设备优化（优先使用 Web Speech API）
- 音频缓存系统（IndexedDB + 本地文件）
- 游戏模式差异化播放（休闲/挑战模式）
- 超时控制和取消令牌系统

### 2.2 Cocos Creator 适配方案

```typescript
// assets/scripts/utils/TTSService.ts
import { _decorator, Component, AudioClip, audioEngine, resources, sys } from 'cc';
const { ccclass } = _decorator;

/**
 * TTS 提供商接口
 */
interface TTSProvider {
    name: string;
    priority: number;
    isAvailable: () => Promise<boolean>;
    speak: (word: string, volume: number) => Promise<number>;
}

/**
 * TTS 服务（Cocos Creator 版本）
 */
@ccclass('TTSService')
export class TTSService extends Component {
    private static _instance: TTSService = null;
    
    // TTS 提供商
    private providers: TTSProvider[] = [];
    private currentProvider: TTSProvider | null = null;
    
    // 取消令牌系统
    private currentSpeakId: number = 0;
    private activeSpeakIds: Set<number> = new Set();
    private cancelledSpeakIds: Set<number> = new Set();
    
    // 音频缓存
    private cacheManager: AudioCacheManager | null = null;
    private cacheEnabled: boolean = true;
    
    // 播放状态
    private currentAudioID: number = -1;
    private repeatTimer: number = -1;
    
    /**
     * 单例模式
     */
    public static getInstance(): TTSService {
        if (!this._instance) {
            const node = new Node('TTSService');
            this._instance = node.addComponent(TTSService);
            director.addPersistRootNode(node);
        }
        return this._instance;
    }
    
    /**
     * 初始化
     */
    public async initialize(): Promise<void> {
        console.log('TTSService: 初始化');
        
        // 1. 初始化缓存管理器
        if (this.cacheEnabled) {
            this.cacheManager = AudioCacheManager.getInstance();
            await this.cacheManager.initialize();
        }
        
        // 2. 注册 TTS 提供商
        this.registerProviders();
        
        // 3. 测试提供商可用性
        await this.testProviders();
        
        console.log('✅ TTS 服务初始化完成');
    }
    
    /**
     * 注册 TTS 提供商
     */
    private registerProviders(): void {
        const isIOS = sys.os === sys.OS.IOS;
        
        if (isIOS) {
            // iOS 设备：优先使用 Web Speech API
            this.providers = [
                this.createWebSpeechProvider(1),
                this.createYoudaoProvider(2),
                this.createBaiduProvider(3)
            ];
        } else {
            // 其他设备：优先使用第三方 TTS
            this.providers = [
                this.createBaiduProvider(1),
                this.createYoudaoProvider(2),
                this.createBingProvider(3),
                this.createWebSpeechProvider(4)
            ];
        }
    }
    
    /**
     * 创建百度 TTS 提供商
     */
    private createBaiduProvider(priority: number): TTSProvider {
        return {
            name: '百度翻译 TTS',
            priority,
            isAvailable: async () => {
                // 测试是否可访问
                try {
                    const testUrl = 'https://fanyi.baidu.com/gettts?lan=en&text=test';
                    const response = await fetch(testUrl, { method: 'HEAD' });
                    return response.ok;
                } catch {
                    return false;
                }
            },
            speak: async (word: string, volume: number) => {
                const url = `https://fanyi.baidu.com/gettts?lan=en&text=${encodeURIComponent(word)}&spd=5&source=web`;
                return await this.playAudioFromURL(url, 'baidu', word, volume);
            }
        };
    }
    
    /**
     * 创建有道 TTS 提供商
     */
    private createYoudaoProvider(priority: number): TTSProvider {
        return {
            name: '有道智云 TTS',
            priority,
            isAvailable: async () => {
                try {
                    const testUrl = 'https://dict.youdao.com/dictvoice?audio=test&type=1';
                    const response = await fetch(testUrl, { method: 'HEAD' });
                    return response.ok;
                } catch {
                    return false;
                }
            },
            speak: async (word: string, volume: number) => {
                const url = `https://dict.youdao.com/dictvoice?audio=${encodeURIComponent(word)}&type=1`;
                return await this.playAudioFromURL(url, 'youdao', word, volume);
            }
        };
    }
    
    /**
     * 创建 Bing TTS 提供商
     */
    private createBingProvider(priority: number): TTSProvider {
        return {
            name: '微软 Bing TTS',
            priority,
            isAvailable: async () => {
                // Bing TTS 通常可用
                return true;
            },
            speak: async (word: string, volume: number) => {
                const url = `https://www.bing.com/tts/v1?text=${encodeURIComponent(word)}&lang=en-GB`;
                return await this.playAudioFromURL(url, 'bing', word, volume);
            }
        };
    }
    
    /**
     * 创建 Web Speech API 提供商
     */
    private createWebSpeechProvider(priority: number): TTSProvider {
        return {
            name: 'Web Speech API',
            priority,
            isAvailable: async () => {
                return 'speechSynthesis' in window;
            },
            speak: async (word: string, volume: number) => {
                return new Promise((resolve, reject) => {
                    if (!('speechSynthesis' in window)) {
                        reject(new Error('Web Speech API 不可用'));
                        return;
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(word);
                    utterance.lang = 'en-GB'; // 英式英语
                    utterance.volume = volume;
                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;
                    
                    utterance.onend = () => resolve(1); // 返回虚拟 audioID
                    utterance.onerror = (e) => reject(e);
                    
                    window.speechSynthesis.speak(utterance);
                });
            }
        };
    }
    
    /**
     * 从 URL 播放音频（带缓存）
     */
    private async playAudioFromURL(url: string, provider: string, 
                                   word: string, volume: number): Promise<number> {
        // 如果启用缓存
        if (this.cacheEnabled && this.cacheManager && word) {
            // 1. 检查缓存
            if (await this.cacheManager.hasCache(word, provider)) {
                const cachedClip = await this.cacheManager.getCache(word, provider);
                return this.playAudioClip(cachedClip, volume);
            }
            
            // 2. 下载音频
            const audioBlob = await this.downloadAudio(url);
            
            // 3. 保存缓存（异步，不阻塞播放）
            this.cacheManager.saveCache(word, provider, audioBlob);
            
            // 4. 转换为 AudioClip 播放
            const clip = await this.blobToAudioClip(audioBlob);
            return this.playAudioClip(clip, volume);
        }
        
        // 未启用缓存，直接加载远程音频
        return new Promise((resolve, reject) => {
            assetManager.loadRemote(url, { ext: '.mp3' }, (err, clip: AudioClip) => {
                if (err) {
                    reject(err);
                } else {
                    const audioID = this.playAudioClip(clip, volume);
                    resolve(audioID);
                }
            });
        });
    }
    
    /**
     * 播放 AudioClip
     */
    private playAudioClip(clip: AudioClip, volume: number): number {
        const audioID = audioEngine.play(clip, false, volume);
        this.currentAudioID = audioID;
        return audioID;
    }
    
    /**
     * 下载音频
     */
    private async downloadAudio(url: string): Promise<Blob> {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return await response.blob();
    }
    
    /**
     * Blob 转 AudioClip
     */
    private async blobToAudioClip(blob: Blob): Promise<AudioClip> {
        // 在 Cocos Creator 中，需要通过 URL 加载
        const blobUrl = URL.createObjectURL(blob);
        
        return new Promise((resolve, reject) => {
            assetManager.loadRemote(blobUrl, { ext: '.mp3' }, (err, clip: AudioClip) => {
                URL.revokeObjectURL(blobUrl);
                
                if (err) {
                    reject(err);
                } else {
                    resolve(clip);
                }
            });
        });
    }
    
    /**
     * 测试提供商
     */
    private async testProviders(): Promise<void> {
        console.log('测试 TTS 提供商...');
        
        for (const provider of this.providers) {
            const available = await provider.isAvailable();
            console.log(`${provider.name}: ${available ? '✅ 可用' : '❌ 不可用'}`);
            
            if (available && !this.currentProvider) {
                this.currentProvider = provider;
            }
        }
        
        if (!this.currentProvider) {
            console.warn('⚠️ 没有可用的 TTS 提供商');
        }
    }
    
    /**
     * 朗读单词
     */
    public async speak(word: string, options?: any): Promise<void> {
        const speakId = ++this.currentSpeakId;
        this.activeSpeakIds.add(speakId);
        
        try {
            // 检查是否被取消
            if (this.cancelledSpeakIds.has(speakId)) {
                return;
            }
            
            const volume = options?.volume || 1.0;
            
            // 尝试所有提供商
            for (const provider of this.providers) {
                try {
                    const audioID = await provider.speak(word, volume);
                    this.currentAudioID = audioID;
                    
                    console.log(`✅ 播放成功: ${word} (${provider.name})`);
                    break;
                    
                } catch (error) {
                    console.warn(`⚠️ ${provider.name} 失败:`, error);
                    continue;
                }
            }
            
        } finally {
            this.activeSpeakIds.delete(speakId);
            this.cancelledSpeakIds.delete(speakId);
        }
    }
    
    /**
     * 停止播放
     */
    public stop(setCancelled: boolean = true): void {
        // 停止当前音频
        if (this.currentAudioID !== -1) {
            audioEngine.stop(this.currentAudioID);
            this.currentAudioID = -1;
        }
        
        // 停止 Web Speech API
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
        }
        
        // 清除定时器
        if (this.repeatTimer !== -1) {
            this.unschedule(this.repeatTimer);
            this.repeatTimer = -1;
        }
        
        // 标记取消
        if (setCancelled) {
            this.activeSpeakIds.forEach(id => {
                this.cancelledSpeakIds.add(id);
            });
        }
    }
    
    /**
     * 重复播放
     */
    public startRepeat(word: string, interval: number = 5000): void {
        this.stopRepeat();
        
        this.repeatTimer = setInterval(() => {
            this.speak(word);
        }, interval);
    }
    
    /**
     * 停止重复
     */
    public stopRepeat(): void {
        if (this.repeatTimer !== -1) {
            clearInterval(this.repeatTimer);
            this.repeatTimer = -1;
        }
    }
    
    /**
     * 清理
     */
    public cleanup(): void {
        this.stop();
        this.stopRepeat();
        this.cacheManager?.clearBlobUrlCache();
    }
}
```

---

## 3️⃣ 音频缓存管理器

### 3.1 AudioCacheManager 实现

```typescript
// assets/scripts/utils/AudioCacheManager.ts
import { AudioClip, sys } from 'cc';

/**
 * 音频缓存管理器（Cocos Creator 版本）
 */
export class AudioCacheManager {
    private static _instance: AudioCacheManager = null;
    
    private dbName: string = 'WordTetrisAudioCache';
    private dbVersion: number = 1;
    private storeName: string = 'audios';
    private db: IDBDatabase | null = null;
    
    private blobUrlCache: Map<string, string> = new Map();
    private isLocal: boolean = false;
    
    /**
     * 单例模式
     */
    public static getInstance(): AudioCacheManager {
        if (!this._instance) {
            this._instance = new AudioCacheManager();
        }
        return this._instance;
    }
    
    /**
     * 初始化
     */
    public async initialize(): Promise<void> {
        // 检测环境
        this.isLocal = this.isLocalDevelopment();
        
        // 初始化 IndexedDB
        if (sys.isBrowser) {
            await this.initDB();
        }
        
        console.log('✅ 音频缓存管理器初始化完成');
        console.log(`   环境: ${this.isLocal ? '本地开发' : 'Web部署'}`);
    }
    
    /**
     * 初始化 IndexedDB
     */
    private initDB(): Promise<void> {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = (event.target as IDBOpenDBRequest).result;
                
                if (!db.objectStoreNames.contains(this.storeName)) {
                    const store = db.createObjectStore(this.storeName, { 
                        keyPath: 'id', 
                        autoIncrement: true 
                    });
                    
                    // 创建复合索引
                    store.createIndex('word_provider', ['word', 'provider'], { unique: true });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    }
    
    /**
     * 检查缓存是否存在
     */
    public async hasCache(word: string, provider: string): Promise<boolean> {
        // 1. 检查本地文件
        if (this.isLocal) {
            const hasLocal = await this.checkLocalFile(word, provider);
            if (hasLocal) return true;
        }
        
        // 2. 检查 IndexedDB
        if (this.db) {
            try {
                const data = await this.getFromDB(word, provider);
                return !!data;
            } catch {
                return false;
            }
        }
        
        return false;
    }
    
    /**
     * 获取缓存
     */
    public async getCache(word: string, provider: string): Promise<AudioClip> {
        const cacheKey = `${word}_${provider}`;
        
        // 1. 检查内存缓存
        if (this.blobUrlCache.has(cacheKey)) {
            const blobUrl = this.blobUrlCache.get(cacheKey);
            return await this.loadAudioClipFromURL(blobUrl);
        }
        
        // 2. 检查本地文件
        if (this.isLocal) {
            const localPath = this.getLocalFilePath(word, provider);
            try {
                const clip = await this.loadLocalAudioClip(localPath);
                return clip;
            } catch {
                // 继续尝试 IndexedDB
            }
        }
        
        // 3. 从 IndexedDB 读取
        if (this.db) {
            const data = await this.getFromDB(word, provider);
            if (data && data.blob) {
                const blobUrl = URL.createObjectURL(data.blob);
                this.blobUrlCache.set(cacheKey, blobUrl);
                
                return await this.loadAudioClipFromURL(blobUrl);
            }
        }
        
        throw new Error('缓存不存在');
    }
    
    /**
     * 保存缓存
     */
    public async saveCache(word: string, provider: string, audioBlob: Blob): Promise<void> {
        if (this.isLocal) {
            // 本地开发：提示下载文件
            this.promptDownloadFile(word, provider, audioBlob);
        } else {
            // Web 部署：保存到 IndexedDB
            await this.saveToDB(word, provider, audioBlob);
        }
    }
    
    /**
     * 从 IndexedDB 读取
     */
    private getFromDB(word: string, provider: string): Promise<any> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.storeName], 'readonly');
            const store = transaction.objectStore(this.storeName);
            const index = store.index('word_provider');
            const request = index.get([word.toLowerCase(), provider.toLowerCase()]);
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
    
    /**
     * 保存到 IndexedDB
     */
    private saveToDB(word: string, provider: string, audioBlob: Blob): Promise<void> {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);
            
            const data = {
                word: word.toLowerCase(),
                provider: provider.toLowerCase(),
                blob: audioBlob,
                timestamp: Date.now()
            };
            
            const request = store.add(data);
            
            request.onsuccess = () => {
                console.log(`💾 保存到 IndexedDB: ${word}_${provider}`);
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }
    
    /**
     * 检查本地文件
     */
    private async checkLocalFile(word: string, provider: string): Promise<boolean> {
        const path = this.getLocalFilePath(word, provider);
        
        return new Promise((resolve) => {
            resources.load(path, AudioClip, (err) => {
                resolve(!err);
            });
        });
    }
    
    /**
     * 加载本地音频文件
     */
    private loadLocalAudioClip(path: string): Promise<AudioClip> {
        return new Promise((resolve, reject) => {
            resources.load(path, AudioClip, (err, clip) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(clip);
                }
            });
        });
    }
    
    /**
     * 从 URL 加载 AudioClip
     */
    private loadAudioClipFromURL(url: string): Promise<AudioClip> {
        return new Promise((resolve, reject) => {
            assetManager.loadRemote(url, { ext: '.mp3' }, (err, clip: AudioClip) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(clip);
                }
            });
        });
    }
    
    /**
     * 获取本地文件路径
     */
    private getLocalFilePath(word: string, provider: string): string {
        return `audio/tts/${word.toLowerCase()}_${provider.toLowerCase()}`;
    }
    
    /**
     * 判断是否本地开发环境
     */
    private isLocalDevelopment(): boolean {
        if (!sys.isBrowser) {
            return false;
        }
        
        const hostname = location.hostname;
        return hostname === 'localhost' || 
               hostname === '127.0.0.1' || 
               hostname === '' ||
               hostname.startsWith('192.168.') ||
               hostname.startsWith('10.');
    }
    
    /**
     * 提示下载文件（本地开发）
     */
    private promptDownloadFile(word: string, provider: string, audioBlob: Blob): void {
        const fileName = `${word.toLowerCase()}_${provider.toLowerCase()}.mp3`;
        
        console.log(`💡 建议下载文件: ${fileName}`);
        console.log(`   保存到: assets/resources/audio/tts/${fileName}`);
        
        // 添加到下载队列
        if (!window['_audioCacheDownloadQueue']) {
            window['_audioCacheDownloadQueue'] = [];
        }
        
        window['_audioCacheDownloadQueue'].push({
            word,
            provider,
            blob: audioBlob,
            fileName
        });
    }
    
    /**
     * 清空内存缓存
     */
    public clearBlobUrlCache(): void {
        this.blobUrlCache.forEach(blobUrl => {
            URL.revokeObjectURL(blobUrl);
        });
        this.blobUrlCache.clear();
    }
    
    /**
     * 获取缓存统计
     */
    public async getStats(): Promise<any> {
        if (!this.db) {
            return { total: 0, totalSizeMB: '0', items: [] };
        }
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([this.storeName], 'readonly');
            const store = transaction.objectStore(this.storeName);
            const request = store.getAll();
            
            request.onsuccess = () => {
                const items = request.result;
                let totalSize = 0;
                
                items.forEach(item => {
                    if (item.blob) {
                        totalSize += item.blob.size;
                    }
                });
                
                resolve({
                    total: items.length,
                    totalSizeMB: (totalSize / 1024 / 1024).toFixed(2),
                    items: items.map(item => ({
                        word: item.word,
                        provider: item.provider,
                        size: (item.blob?.size / 1024).toFixed(2) + ' KB',
                        date: new Date(item.timestamp).toLocaleString()
                    }))
                });
            };
            
            request.onerror = () => reject(request.error);
        });
    }
}
```

---

## 4️⃣ 游戏中的音频集成

### 4.1 GameManager 中使用 TTS

```typescript
// assets/scripts/core/GameManager.ts
import { TTSService } from '../utils/TTSService';

@ccclass('GameManager')
export class GameManager extends Component {
    private ttsService: TTSService = null;
    
    protected async onLoad(): Promise<void> {
        // 初始化 TTS 服务
        this.ttsService = TTSService.getInstance();
        await this.ttsService.initialize();
    }
    
    /**
     * 单词开始下降时播放语音
     */
    private onWordReleased(word: WordEntity): void {
        const wordText = word.getWord();
        
        // 立即播放一次
        this.ttsService.speak(wordText);
        
        // 每 5 秒重复播放
        this.ttsService.startRepeat(wordText, 5000);
    }
    
    /**
     * 单词被击落或堆叠时停止语音
     */
    private onWordRemoved(): void {
        this.ttsService.stop();
        this.ttsService.stopRepeat();
    }
    
    /**
     * 游戏暂停时停止语音
     */
    public pauseGame(): void {
        this.isPaused = true;
        this.ttsService.stop();
    }
    
    /**
     * 清理
     */
    protected onDestroy(): void {
        this.ttsService.cleanup();
    }
}
```

---

## 5️⃣ 验证清单

- [ ] TTS 服务初始化成功
- [ ] 多提供商降级正常工作
- [ ] iOS 设备优先使用 Web Speech API
- [ ] 音频缓存系统工作正常
- [ ] IndexedDB 缓存持久化
- [ ] 本地开发环境文件提示
- [ ] 音频播放流畅
- [ ] 重复播放正常
- [ ] 暂停/停止功能正常
- [ ] 音量控制有效

---

**音频系统适配完成！** ✅

下一步：阅读 [09_测试验证清单.md](./09_测试验证清单.md)




